<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테트리스</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            overflow: hidden;
        }

        .game-header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
            z-index: 10;
            position: relative;
            padding-bottom: 20px;
        }

        .game-header h1 {
            font-size: 48px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            user-select: none;
            pointer-events: none;
        }

        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .game-header p {
            font-size: 18px;
            margin: 10px 0 0 0;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-container {
            display: grid;
            grid-template-columns: 250px auto 250px;
            gap: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(255, 255, 255, 0.15);
            align-items: start;
            transform: scale(1.05);
            max-width: 90vw;
        }

        .game-board {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
        }

        canvas {
            display: block;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: #000;
            outline: none;
        }

        canvas:focus {
            outline: none;
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 18px;
            width: 250px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            color: white;
            min-height: 80px;
        }

        .info-box h2 {
            font-size: 20px;
            margin-bottom: 12px;
            text-align: center;
            color: #fff;
        }

        .score-value, .level-value, .lines-value {
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            margin: 12px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .next-level {
            font-size: 14px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        .next-piece {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            color: white;
            font-size: 15px;
        }

        .controls h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 14px;
        }

        .controls p {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .audio-controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            color: white;
            font-size: 15px;
            box-sizing: border-box;
        }

        .audio-controls h3 {
            margin-bottom: 10px;
            text-align: center;
            font-size: 14px;
        }

        .audio-controls label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }

        .audio-controls input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .audio-controls button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .audio-controls button:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
            width: 100%;
        }

        .toggle-label {
            color: white;
            font-size: 15px;
            font-weight: 500;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.3);
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #4CAF50;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .audio-controls select {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .audio-controls input[type="file"] {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            cursor: pointer;
        }

        .audio-controls input[type="file"]::file-selector-button {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 10px;
        }

        .controls kbd {
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 8px;
            border-radius: 3px;
            font-family: monospace;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over.show {
            display: block;
        }

        .game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .game-over button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-over button:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            display: none;
        }

        .pause-indicator.show {
            display: block;
        }

        .line-clear-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 500;
            animation: effectPulse 1.5s ease-out;
        }

        .line-clear-effect.show {
            display: block;
        }

        .line-clear-effect.good {
            color: #4CAF50;
            text-shadow: 0 0 10px #4CAF50;
        }

        .line-clear-effect.excellent {
            color: #2196F3;
            text-shadow: 0 0 15px #2196F3;
        }

        .line-clear-effect.great {
            color: #FF9800;
            text-shadow: 0 0 20px #FF9800;
        }

        @keyframes effectPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .level-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 48px;
            font-weight: bold;
            display: none;
            z-index: 1000;
        }

        .level-transition.show {
            display: flex;
        }

        .level-transition h1 {
            font-size: 64px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 0 0 20px #FFD700;
        }

        .level-transition p {
            font-size: 36px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>두뇌발달 테트리스 게임</h1>
        <p>🧠 Brain Training Tetris - 50 Levels Challenge 🎮</p>
    </div>
    <div class="game-container">
        <div class="left-panel">
            <div class="info-box">
                <h2>점수</h2>
                <div class="score-value" id="score">0</div>
            </div>

            <div class="info-box">
                <h2>레벨</h2>
                <div class="level-value" id="level">1</div>
                <div class="next-level" id="nextLevel">다음: 500점</div>
            </div>

            <div class="info-box">
                <h2>라인</h2>
                <div class="lines-value" id="lines">0</div>
            </div>

            <div class="controls">
                <h3>조작법</h3>
                <p><span>좌우 이동</span><kbd>←</kbd> <kbd>→</kbd></p>
                <p><span>회전</span><kbd>↑</kbd></p>
                <p><span>빠른 낙하</span><kbd>↓</kbd></p>
                <p><span>즉시 낙하</span><kbd>Space</kbd></p>
                <p><span>일시정지</span><kbd>P</kbd></p>
            </div>
        </div>

        <div class="game-board">
            <canvas id="tetris" width="400" height="800"></canvas>
            <div class="pause-indicator" id="pauseIndicator">일시정지</div>
            <div class="line-clear-effect" id="lineClearEffect">GOOD!</div>
        </div>

        <div class="right-panel">
            <div class="info-box">
                <h2>다음 블록</h2>
                <canvas id="nextPiece" width="160" height="160" class="next-piece"></canvas>
            </div>

            <div class="audio-controls">
                <h3>음악 설정</h3>
                <label>
                    음악 파일:
                    <input type="file" id="musicFile" accept="audio/*" onchange="loadCustomMusic()">
                </label>
                <div id="recentMusicList" style="display: none;">
                    <label>최근 사용한 음악:</label>
                    <select id="recentMusic" onchange="loadRecentMusic()">
                        <option value="">선택하세요</option>
                    </select>
                </div>
                <label>
                    볼륨: <span id="musicVolumeLabel">30%</span>
                    <input type="range" id="musicVolume" min="0" max="100" value="30" oninput="changeMusicVolume()">
                </label>
                <div class="toggle-switch">
                    <span class="toggle-label">음악</span>
                    <label class="switch">
                        <input type="checkbox" id="musicToggle" onchange="toggleBackgroundMusic()">
                        <span class="slider"></span>
                    </label>
                </div>
                <button onclick="clearRecentMusic()" style="background: rgba(255, 0, 0, 0.3); margin-top: 5px;">최근 음악 삭제</button>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h1>게임 오버</h1>
        <p style="font-size: 24px; margin: 20px 0;">최종 점수: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">다시 시작</button>
    </div>

    <div class="level-transition" id="levelTransition">
        <h1>CLEAR!</h1>
        <p>Next Level</p>
        <p id="nextLevelNumber">Level 2</p>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextPiece');
        const nextCtx = nextCanvas.getContext('2d');

        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 40;

        const COLORS = [
            '#000000',
            '#00ffff', // I-piece - Cyan
            '#0000ff', // J-piece - Blue
            '#ff8c00', // L-piece - Orange
            '#ffff00', // O-piece - Yellow
            '#00ff00', // S-piece - Green
            '#800080', // T-piece - Purple
            '#ff0000'  // Z-piece - Red
        ];

        // Sound system with single AudioContext for stability
        let audioContext = null;
        let soundEnabled = true;
        let backgroundMusic = null;
        let musicGain = null;
        let musicVolume = 0.3;
        let musicEnabled = false;
        let customAudio = null;
        let isCustomMusicPlaying = false;
        let recentMusicList = [];
        let lastUsedMusic = null;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                return true;
            } catch (e) {
                soundEnabled = false;
                return false;
            }
        }

        function startBackgroundMusic() {
            if (!musicEnabled || !customAudio) {
                console.log('Cannot start music:', 'enabled:', musicEnabled, 'audio:', !!customAudio);
                return;
            }

            try {
                customAudio.volume = musicVolume;
                customAudio.currentTime = 0;

                const playPromise = customAudio.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        isCustomMusicPlaying = true;
                        console.log('Music started successfully');
                    }).catch(e => {
                        console.log('Auto-play blocked, waiting for user interaction:', e.message);

                        // 사용자 상호작용 대기
                        const playOnInteraction = () => {
                            if (musicEnabled && customAudio) {
                                customAudio.play().then(() => {
                                    isCustomMusicPlaying = true;
                                    console.log('Music started after user interaction');
                                }).catch(err => console.log('User interaction play failed:', err));
                            }
                        };

                        // 게임 조작으로도 음악 시작 가능
                        document.addEventListener('click', playOnInteraction, { once: true });
                        document.addEventListener('keydown', playOnInteraction, { once: true });
                    });
                } else {
                    isCustomMusicPlaying = true;
                }
            } catch (e) {
                console.error('Start music error:', e);
            }
        }

        function stopBackgroundMusic() {
            if (customAudio && isCustomMusicPlaying) {
                customAudio.pause();
                isCustomMusicPlaying = false;
            }
        }


        function saveToRecentMusic(fileName, audioData) {
            // 파일 크기 체크 (10MB 이상이면 저장 안함)
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (audioData.length > maxSize) {
                console.log('File too large for storage, skipping recent music save');
                alert('파일이 너무 커서 최근 음악 목록에 저장되지 않습니다. (10MB 제한)');
                return;
            }

            try {
                // 최근 음악 리스트에 추가 (최대 3개로 줄임)
                const musicItem = { name: fileName, data: audioData, timestamp: Date.now() };

                // 같은 파일이 이미 있으면 제거
                recentMusicList = recentMusicList.filter(item => item.name !== fileName);

                // 맨 앞에 추가
                recentMusicList.unshift(musicItem);

                // 최대 3개까지만 유지 (용량 절약)
                if (recentMusicList.length > 3) {
                    recentMusicList = recentMusicList.slice(0, 3);
                }

                // 로컬스토리지에 저장 시도
                localStorage.setItem('tetrisRecentMusic', JSON.stringify(recentMusicList));
                localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(musicItem));

                console.log('Music saved to recent list');
                // UI 업데이트
                updateRecentMusicUI();
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.log('Storage quota exceeded, clearing old music');
                    alert('저장 공간이 부족해서 이전 음악들을 삭제합니다.');

                    // 기존 음악 모두 삭제
                    recentMusicList = [];
                    localStorage.removeItem('tetrisRecentMusic');
                    localStorage.removeItem('tetrisLastUsedMusic');

                    // 현재 음악만 저장 (파일이 작으면)
                    if (audioData.length <= maxSize) {
                        try {
                            const musicItem = { name: fileName, data: audioData, timestamp: Date.now() };
                            recentMusicList = [musicItem];
                            localStorage.setItem('tetrisRecentMusic', JSON.stringify(recentMusicList));
                            localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(musicItem));
                        } catch (e2) {
                            console.log('Still too large, skipping storage');
                        }
                    }

                    updateRecentMusicUI();
                } else {
                    console.error('Storage error:', e);
                }
            }
        }

        function loadRecentMusicList() {
            try {
                const saved = localStorage.getItem('tetrisRecentMusic');
                if (saved) {
                    recentMusicList = JSON.parse(saved);
                    updateRecentMusicUI();
                }
            } catch (e) {
                recentMusicList = [];
            }
        }

        function updateRecentMusicUI() {
            const recentMusicDiv = document.getElementById('recentMusicList');
            const recentMusicSelect = document.getElementById('recentMusic');

            if (recentMusicList.length > 0) {
                recentMusicDiv.style.display = 'block';
                recentMusicSelect.innerHTML = '<option value="">선택하세요</option>';

                recentMusicList.forEach((item, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    // 파일명이 길면 줄임
                    const shortName = item.name.length > 30 ? item.name.substring(0, 30) + '...' : item.name;
                    option.textContent = shortName;
                    option.title = item.name; // 전체 이름은 툴팁으로
                    recentMusicSelect.appendChild(option);
                });
            } else {
                recentMusicDiv.style.display = 'none';
            }
        }

        function loadRecentMusic() {
            const select = document.getElementById('recentMusic');
            const index = parseInt(select.value);

            if (index >= 0 && index < recentMusicList.length) {
                const musicItem = recentMusicList[index];
                loadMusicFromData(musicItem.name, musicItem.data);
            }
        }

        function loadMusicFromData(fileName, audioData) {
            console.log('Loading music:', fileName);

            // Stop current music
            stopBackgroundMusic();

            // Create new audio element
            if (customAudio) {
                customAudio.pause();
                customAudio.src = '';
                customAudio = null;
            }

            try {
                customAudio = new Audio(audioData);
                customAudio.loop = true;
                customAudio.volume = musicVolume;

                // 음악 로드 완료 후 처리
                customAudio.addEventListener('canplay', () => {
                    console.log('Audio can play');
                    // 토글 스위치 켜기
                    const toggle = document.getElementById('musicToggle');
                    toggle.checked = true;
                    musicEnabled = true;

                    // 즉시 재생 시도
                    startBackgroundMusic();
                });

                customAudio.addEventListener('error', (e) => {
                    console.error('Audio load error:', e);
                });

                // 최근 사용 음악 업데이트
                lastUsedMusic = { name: fileName, data: audioData };
                localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(lastUsedMusic));

            } catch (e) {
                console.error('Failed to create audio:', e);
            }
        }

        function autoPlayLastMusic() {
            try {
                const lastMusic = localStorage.getItem('tetrisLastUsedMusic');
                if (lastMusic) {
                    lastUsedMusic = JSON.parse(lastMusic);
                    console.log('Loading last used music:', lastUsedMusic.name);

                    // 즉시 로드 (재생은 사용자가 토글로 제어)
                    if (lastUsedMusic) {
                        // 음악 파일 로드만 하고 자동 재생하지 않음
                        if (customAudio) {
                            customAudio.pause();
                            customAudio = null;
                        }

                        customAudio = new Audio(lastUsedMusic.data);
                        customAudio.loop = true;
                        customAudio.volume = musicVolume;

                        console.log('Last music loaded, waiting for user to enable toggle');
                    }
                }
            } catch (e) {
                console.log('Failed to load last used music:', e);
            }
        }

        function clearRecentMusic() {
            recentMusicList = [];
            lastUsedMusic = null;
            localStorage.removeItem('tetrisRecentMusic');
            localStorage.removeItem('tetrisLastUsedMusic');
            updateRecentMusicUI();
            stopBackgroundMusic();
            musicEnabled = false;
        }

        function loadCustomMusic() {
            const fileInput = document.getElementById('musicFile');
            const file = fileInput.files[0];

            if (file) {
                console.log('Loading file:', file.name);
                const reader = new FileReader();
                reader.onload = function(e) {
                    const audioData = e.target.result;
                    console.log('File read complete, size:', audioData.length);

                    // 최근 음악 리스트에 저장
                    saveToRecentMusic(file.name, audioData);

                    // 직접 음악 생성 및 재생
                    createAndPlayMusic(file.name, audioData);
                };
                reader.readAsDataURL(file);
            }
        }

        function createAndPlayMusic(fileName, audioData) {
            console.log('Creating audio for:', fileName);

            // Stop current music
            stopBackgroundMusic();

            // Create new audio element
            if (customAudio) {
                customAudio.pause();
                customAudio.src = '';
                customAudio = null;
            }

            try {
                customAudio = new Audio(audioData);
                customAudio.loop = true;
                customAudio.volume = musicVolume;

                // 토글 스위치 켜기
                const toggle = document.getElementById('musicToggle');
                toggle.checked = true;
                musicEnabled = true;

                // 즉시 재생 시도 (사용자 제스처 필요)
                console.log('Attempting to play music...');
                customAudio.play().then(() => {
                    isCustomMusicPlaying = true;
                    console.log('Music playing successfully!');
                }).catch(e => {
                    console.log('Need user interaction to play:', e.message);

                    // 알림 표시
                    alert('음악을 재생하려면 화면을 클릭하거나 키를 누르세요.');

                    // 다음 클릭/키 입력에서 재생
                    const playOnClick = () => {
                        customAudio.play().then(() => {
                            isCustomMusicPlaying = true;
                            console.log('Music started after user interaction');
                        }).catch(err => console.log('Still failed:', err));
                    };

                    document.addEventListener('click', playOnClick, { once: true });
                    document.addEventListener('keydown', playOnClick, { once: true });
                });

                // 최근 사용 음악 업데이트
                lastUsedMusic = { name: fileName, data: audioData };
                localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(lastUsedMusic));

            } catch (e) {
                console.error('Failed to create audio:', e);
            }
        }

        function changeMusicVolume() {
            const slider = document.getElementById('musicVolume');
            const label = document.getElementById('musicVolumeLabel');
            musicVolume = slider.value / 100;
            label.textContent = slider.value + '%';

            // Update custom audio volume
            if (customAudio) {
                customAudio.volume = musicVolume;
            }
        }

        function toggleBackgroundMusic() {
            const toggle = document.getElementById('musicToggle');
            musicEnabled = toggle.checked;

            console.log('Music toggle:', musicEnabled, 'Has audio:', !!customAudio);

            if (musicEnabled && customAudio) {
                startBackgroundMusic();
            } else {
                stopBackgroundMusic();
            }
        }

        function createSound(frequency, duration, type = 'sine', volume = 0.3) {
            if (!soundEnabled || !audioContext) return;

            try {
                // Resume context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Silent fail
            }
        }

        function playSound(soundType) {
            if (!soundEnabled) return;

            try {
                switch(soundType) {
                    case 'move':
                        createSound(200, 0.1, 'sine', 0.2);
                        break;
                    case 'rotate':
                        createSound(300, 0.15, 'sine', 0.25);
                        break;
                    case 'drop':
                        createSound(150, 0.2, 'sine', 0.3);
                        break;
                    case 'clear':
                        setTimeout(() => createSound(500, 0.2, 'sine', 0.4), 0);
                        setTimeout(() => createSound(600, 0.2, 'sine', 0.4), 100);
                        setTimeout(() => createSound(700, 0.3, 'sine', 0.4), 200);
                        break;
                    case 'good':
                        // 2줄 - 강렬한 더블 임팩트
                        setTimeout(() => createSound(300, 0.1, 'sawtooth', 0.6), 0);
                        setTimeout(() => createSound(500, 0.15, 'square', 0.7), 50);
                        setTimeout(() => createSound(700, 0.2, 'sine', 0.6), 150);
                        setTimeout(() => createSound(400, 0.25, 'triangle', 0.5), 300);
                        break;
                    case 'excellent':
                        // 3줄 - 트리플 콤보 사운드
                        setTimeout(() => createSound(350, 0.1, 'sawtooth', 0.7), 0);
                        setTimeout(() => createSound(200, 0.1, 'square', 0.6), 50);
                        setTimeout(() => createSound(600, 0.12, 'sine', 0.8), 100);
                        setTimeout(() => createSound(450, 0.12, 'triangle', 0.7), 180);
                        setTimeout(() => createSound(750, 0.15, 'square', 0.8), 250);
                        setTimeout(() => createSound(850, 0.2, 'sine', 0.7), 350);
                        break;
                    case 'great':
                        // 4줄 - 메가 폭발 사운드
                        setTimeout(() => createSound(150, 0.15, 'sawtooth', 0.8), 0);
                        setTimeout(() => createSound(400, 0.1, 'square', 0.9), 30);
                        setTimeout(() => createSound(250, 0.1, 'sawtooth', 0.7), 60);
                        setTimeout(() => createSound(700, 0.12, 'sine', 0.9), 100);
                        setTimeout(() => createSound(500, 0.1, 'triangle', 0.8), 150);
                        setTimeout(() => createSound(900, 0.15, 'square', 0.9), 200);
                        setTimeout(() => createSound(650, 0.12, 'sine', 0.8), 270);
                        setTimeout(() => createSound(1100, 0.3, 'triangle', 0.9), 350);
                        break;
                    case 'levelUp':
                        setTimeout(() => createSound(400, 0.15, 'sine', 0.5), 0);
                        setTimeout(() => createSound(500, 0.15, 'sine', 0.5), 100);
                        setTimeout(() => createSound(600, 0.15, 'sine', 0.5), 200);
                        setTimeout(() => createSound(700, 0.2, 'sine', 0.5), 300);
                        break;
                    case 'gameOver':
                        createSound(100, 0.8, 'sawtooth', 0.3);
                        break;
                }
            } catch (e) {
                // Silent fail
            }
        }

        // Initialize audio on first user interaction
        function enableAudio() {
            if (!audioContext) {
                initAudio();
            }
        }

        // Auto-initialize audio when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Try to initialize audio immediately
            initAudio();
            // Load recent music list and auto-play last used music
            loadRecentMusicList();
            autoPlayLastMusic();
        });

        // Also try when user first interacts with the page
        document.addEventListener('click', enableAudio, { once: true });
        document.addEventListener('keydown', enableAudio, { once: true });

        // Calculate current level based on score
        function calculateLevel(currentScore) {
            for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
                if (currentScore >= LEVEL_THRESHOLDS[i]) {
                    return i + 1;
                }
            }
            return 1;
        }

        // Get next level score requirement
        function getNextLevelScore(currentLevel) {
            if (currentLevel < LEVEL_THRESHOLDS.length) {
                return LEVEL_THRESHOLDS[currentLevel];
            }
            return LEVEL_THRESHOLDS[LEVEL_THRESHOLDS.length - 1];
        }

        // Calculate drop speed based on level and time
        function calculateDropSpeed(currentLevel) {
            // 레벨이 높아질수록 더 빨라짐 (최소 50ms, 최대 1000ms)
            const baseSpeed = 1000;
            const levelSpeedReduction = (currentLevel - 1) * 80;

            // 시간에 따른 점진적 속도 증가 (30초마다 5ms씩 빨라짐)
            const currentTime = performance.now();
            const elapsedSeconds = (currentTime - gameStartTime) / 1000;
            timeSpeedBonus = Math.floor(elapsedSeconds / 30) * 5; // 30초마다 5ms 빨라짐

            const finalSpeed = baseSpeed - levelSpeedReduction - timeSpeedBonus;
            return Math.max(50, finalSpeed);
        }

        // Level progression system - score requirements for each level (50단계까지 확장)
        const LEVEL_THRESHOLDS = [
            0,        // Level 1: 0점
            500,      // Level 2: 500점
            1200,     // Level 3: 1200점
            2500,     // Level 4: 2500점
            4500,     // Level 5: 4500점
            7000,     // Level 6: 7000점
            10000,    // Level 7: 10000점
            14000,    // Level 8: 14000점
            19000,    // Level 9: 19000점
            25000,    // Level 10: 25000점
            32000,    // Level 11: 32000점
            40000,    // Level 12: 40000점
            50000,    // Level 13: 50000점
            62000,    // Level 14: 62000점
            76000,    // Level 15: 76000점
            92000,    // Level 16: 92000점
            110000,   // Level 17: 110000점
            130000,   // Level 18: 130000점
            155000,   // Level 19: 155000점
            200000,   // Level 20: 200000점
            250000,   // Level 21: 250000점
            310000,   // Level 22: 310000점
            380000,   // Level 23: 380000점
            460000,   // Level 24: 460000점
            550000,   // Level 25: 550000점
            650000,   // Level 26: 650000점
            760000,   // Level 27: 760000점
            880000,   // Level 28: 880000점
            1010000,  // Level 29: 1010000점
            1150000,  // Level 30: 1150000점
            1300000,  // Level 31: 1300000점
            1460000,  // Level 32: 1460000점
            1630000,  // Level 33: 1630000점
            1810000,  // Level 34: 1810000점
            2000000,  // Level 35: 2000000점
            2200000,  // Level 36: 2200000점
            2410000,  // Level 37: 2410000점
            2630000,  // Level 38: 2630000점
            2860000,  // Level 39: 2860000점
            3100000,  // Level 40: 3100000점
            3350000,  // Level 41: 3350000점
            3610000,  // Level 42: 3610000점
            3880000,  // Level 43: 3880000점
            4160000,  // Level 44: 4160000점
            4450000,  // Level 45: 4450000점
            4750000,  // Level 46: 4750000점
            5060000,  // Level 47: 5060000점
            5380000,  // Level 48: 5380000점
            5710000,  // Level 49: 5710000점
            6000000   // Level 50: 6000000점
        ];

        const SHAPES = [
            [[1, 1, 1, 1]],
            [[2, 0, 0], [2, 2, 2]],
            [[0, 0, 3], [3, 3, 3]],
            [[4, 4], [4, 4]],
            [[0, 5, 5], [5, 5, 0]],
            [[0, 6, 0], [6, 6, 6]],
            [[7, 7, 0], [0, 7, 7]]
        ];

        let board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let nextPiece = null;
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameLoop = null;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isPaused = false;
        let isGameOver = false;
        let nextLevelScore = 500;  // 다음 레벨까지 필요한 점수
        let gameStartTime = 0;     // 게임 시작 시간
        let timeSpeedBonus = 0;    // 시간에 따른 속도 보너스

        function createPiece() {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            return JSON.parse(JSON.stringify(shape));
        }

        function drawBlock(x, y, color, context = ctx, blockSize = BLOCK_SIZE) {
            const blockX = x * blockSize;
            const blockY = y * blockSize;

            // Main block color
            context.fillStyle = color;
            context.fillRect(blockX, blockY, blockSize, blockSize);

            // Gradient effect
            const gradient = context.createLinearGradient(blockX, blockY, blockX + blockSize, blockY + blockSize);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            context.fillStyle = gradient;
            context.fillRect(blockX, blockY, blockSize, blockSize);

            // Border with rounded corners effect
            context.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            context.lineWidth = 1;
            context.strokeRect(blockX + 1, blockY + 1, blockSize - 2, blockSize - 2);

            context.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            context.lineWidth = 1;
            context.strokeRect(blockX, blockY, blockSize, blockSize);

            // Inner highlight
            context.fillStyle = 'rgba(255, 255, 255, 0.3)';
            context.fillRect(blockX + 2, blockY + 2, blockSize - 8, blockSize - 8);

            // Bottom shadow
            context.fillStyle = 'rgba(0, 0, 0, 0.2)';
            context.fillRect(blockX + 2, blockY + blockSize - 4, blockSize - 4, 2);
        }

        function drawBoard() {
            // Background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }

            // Draw blocks
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, COLORS[board[y][x]]);
                    }
                }
            }
        }

        function drawPiece() {
            if (!currentPiece) return;
            
            for (let y = 0; y < currentPiece.length; y++) {
                for (let x = 0; x < currentPiece[y].length; x++) {
                    if (currentPiece[y][x]) {
                        drawBlock(currentX + x, currentY + y, COLORS[currentPiece[y][x]]);
                    }
                }
            }
        }

        function drawNextPiece() {
            nextCtx.fillStyle = '#000';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (!nextPiece) return;
            
            const offsetX = (4 - nextPiece[0].length) / 2;
            const offsetY = (4 - nextPiece.length) / 2;
            
            for (let y = 0; y < nextPiece.length; y++) {
                for (let x = 0; x < nextPiece[y].length; x++) {
                    if (nextPiece[y][x]) {
                        drawBlock(offsetX + x, offsetY + y, COLORS[nextPiece[y][x]], nextCtx, 40);
                    }
                }
            }
        }

        function collision(piece, x, y) {
            for (let py = 0; py < piece.length; py++) {
                for (let px = 0; px < piece[py].length; px++) {
                    if (piece[py][px]) {
                        const newX = x + px;
                        const newY = y + py;
                        
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        
                        if (newY >= 0 && board[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge() {
            for (let y = 0; y < currentPiece.length; y++) {
                for (let x = 0; x < currentPiece[y].length; x++) {
                    if (currentPiece[y][x]) {
                        if (currentY + y < 0) {
                            gameOver();
                            return;
                        }
                        board[currentY + y][currentX + x] = currentPiece[y][x];
                    }
                }
            }
        }

        function rotate(piece) {
            const rotated = piece[0].map((_, i) => piece.map(row => row[i]).reverse());
            return rotated;
        }

        function showLineClearEffect(linesCleared) {
            const effectElement = document.getElementById('lineClearEffect');
            const effectNames = ['', '', 'GOOD!', 'EXCELLENT!', 'GREAT!'];
            const effectClasses = ['', '', 'good', 'excellent', 'great'];

            effectElement.textContent = effectNames[linesCleared];
            effectElement.className = `line-clear-effect show ${effectClasses[linesCleared]}`;

            setTimeout(() => {
                effectElement.classList.remove('show');
            }, 1500);
        }

        function generateObstacles(level) {
            if (level < 5) return; // 5단계부터 장애물 생성

            // 레벨에 따른 장애물 패턴 - 공중 장애물 포함
            const obstaclePatterns = {
                5: { total: 2, floating: 1 },   // 5단계: 바닥 1줄 + 공중 1줄
                10: { total: 3, floating: 1 },  // 10단계: 바닥 2줄 + 공중 1줄
                15: { total: 4, floating: 2 },  // 15단계: 바닥 2줄 + 공중 2줄
                20: { total: 5, floating: 2 },  // 20단계: 바닥 3줄 + 공중 2줄
                25: { total: 6, floating: 3 },  // 25단계: 바닥 3줄 + 공중 3줄
                30: { total: 7, floating: 3 },  // 30단계: 바닥 4줄 + 공중 3줄
                35: { total: 8, floating: 4 },  // 35단계: 바닥 4줄 + 공중 4줄
                40: { total: 9, floating: 4 },  // 40단계: 바닥 5줄 + 공중 4줄
                45: { total: 10, floating: 5 }, // 45단계: 바닥 5줄 + 공중 5줄
                50: { total: 12, floating: 6 }  // 50단계: 바닥 6줄 + 공중 6줄
            };

            // 현재 레벨에 맞는 장애물 패턴 계산
            let pattern = { total: 0, floating: 0 };
            for (let checkLevel of Object.keys(obstaclePatterns).map(Number).sort((a, b) => b - a)) {
                if (level >= checkLevel) {
                    pattern = obstaclePatterns[checkLevel];
                    break;
                }
            }

            // 바닥 장애물 생성
            const groundRows = pattern.total - pattern.floating;
            for (let row = 0; row < groundRows; row++) {
                const targetRow = ROWS - 1 - row;
                generateObstacleRow(targetRow, row, level, 'ground');
            }

            // 공중 장애물 생성 (게임 보드 중간 부분에)
            for (let i = 0; i < pattern.floating; i++) {
                // 공중 장애물은 게임 보드의 중간~상단 부분에 배치
                const minRow = 3; // 최소 3행 이상에서 시작
                const maxRow = Math.floor(ROWS * 0.7); // 전체 보드의 70% 위치까지
                const targetRow = minRow + (i * Math.floor((maxRow - minRow) / Math.max(1, pattern.floating - 1)));

                generateFloatingObstacle(targetRow, i, level);
            }
        }

        function generateObstacleRow(targetRow, rowIndex, level, type = 'ground') {
            // 레벨과 줄 인덱스에 따른 다양한 패턴
            const patternType = (level + rowIndex) % 6;

            switch(patternType) {
                case 0: // 좌우 대칭 패턴
                    generateSymmetricPattern(targetRow);
                    break;
                case 1: // 계단 패턴
                    generateStairPattern(targetRow, rowIndex);
                    break;
                case 2: // 중앙 집중 패턴
                    generateCenterPattern(targetRow);
                    break;
                case 3: // 좌우 끝 패턴
                    generateSidePattern(targetRow);
                    break;
                case 4: // 체스판 패턴
                    generateCheckerPattern(targetRow, rowIndex);
                    break;
                case 5: // 랜덤 패턴 (기존)
                    generateRandomPattern(targetRow);
                    break;
            }
        }

        function generateSymmetricPattern(targetRow) {
            // 좌우 대칭으로 블록 배치
            const centerGap = 2 + Math.floor(Math.random() * 3); // 2-4칸 가운데 비움
            const startGap = Math.floor((COLS - centerGap) / 2);

            for (let col = 0; col < COLS; col++) {
                if (col < startGap || col >= startGap + centerGap) {
                    // 80% 확률로 블록 배치
                    if (Math.random() < 0.8) {
                        board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                    }
                }
            }
        }

        function generateStairPattern(targetRow, rowIndex) {
            // 계단 모양 패턴
            const direction = rowIndex % 2 === 0 ? 1 : -1; // 좌우 번갈아
            const steps = 3;

            for (let col = 0; col < COLS; col++) {
                const stepPosition = direction > 0 ?
                    Math.floor(col / steps) :
                    Math.floor((COLS - 1 - col) / steps);

                if (stepPosition % 2 === rowIndex % 2) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateCenterPattern(targetRow) {
            // 중앙에 집중된 패턴, 양쪽 끝 비움
            for (let col = 2; col < COLS - 2; col++) {
                if (Math.random() < 0.85) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateSidePattern(targetRow) {
            // 양쪽 끝에만 블록, 중앙 비움
            const sideWidth = 3;

            for (let col = 0; col < sideWidth; col++) {
                if (Math.random() < 0.9) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }

            for (let col = COLS - sideWidth; col < COLS; col++) {
                if (Math.random() < 0.9) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateCheckerPattern(targetRow, rowIndex) {
            // 체스판 무늬 패턴
            for (let col = 0; col < COLS; col++) {
                if ((col + rowIndex) % 2 === 0) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateRandomPattern(targetRow) {
            // 기존 랜덤 패턴
            const fillRate = 0.6 + Math.random() * 0.2;
            const blocksToFill = Math.floor(COLS * fillRate);

            const positions = Array.from({length: COLS}, (_, i) => i);
            const randomPositions = positions.sort(() => Math.random() - 0.5).slice(0, blocksToFill);

            randomPositions.forEach(col => {
                board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
            });
        }

        function generateFloatingObstacle(targetRow, obstacleIndex, level) {
            // 공중 장애물 패턴 - 더 전략적인 배치
            const floatingPatterns = [
                'bridge',        // 다리 형태 (양쪽 끝만 비워둠)
                'islands',       // 섬 형태 (작은 블록 덩어리들)
                'tunnel',        // 터널 형태 (가운데만 비워둠)
                'scattered',     // 흩어진 형태 (랜덤하게 배치)
                'zigzag',        // 지그재그 형태
                'platform'       // 플랫폼 형태 (중간에 큰 공간)
            ];

            const patternType = floatingPatterns[(level + obstacleIndex) % floatingPatterns.length];

            switch(patternType) {
                case 'bridge':
                    generateBridgePattern(targetRow);
                    break;
                case 'islands':
                    generateIslandsPattern(targetRow);
                    break;
                case 'tunnel':
                    generateTunnelPattern(targetRow);
                    break;
                case 'scattered':
                    generateScatteredPattern(targetRow);
                    break;
                case 'zigzag':
                    generateZigzagPattern(targetRow, obstacleIndex);
                    break;
                case 'platform':
                    generatePlatformPattern(targetRow);
                    break;
            }
        }

        function generateBridgePattern(targetRow) {
            // 양쪽 끝 1-2칸만 비워두고 나머지 채움
            const leftGap = 1 + Math.floor(Math.random() * 2);
            const rightGap = 1 + Math.floor(Math.random() * 2);

            for (let col = leftGap; col < COLS - rightGap; col++) {
                board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
            }
        }

        function generateIslandsPattern(targetRow) {
            // 작은 블록 덩어리들 생성
            const islands = Math.floor(Math.random() * 3) + 2; // 2-4개의 섬

            for (let i = 0; i < islands; i++) {
                const islandSize = Math.floor(Math.random() * 3) + 1; // 1-3칸 크기
                const startCol = Math.floor(Math.random() * (COLS - islandSize));

                for (let j = 0; j < islandSize; j++) {
                    if (startCol + j < COLS && board[targetRow][startCol + j] === 0) {
                        board[targetRow][startCol + j] = Math.floor(Math.random() * 7) + 1;
                    }
                }
            }
        }

        function generateTunnelPattern(targetRow) {
            // 가운데 2-4칸만 비워두고 나머지 채움
            const tunnelSize = 2 + Math.floor(Math.random() * 3);
            const tunnelStart = Math.floor((COLS - tunnelSize) / 2);

            for (let col = 0; col < COLS; col++) {
                if (col < tunnelStart || col >= tunnelStart + tunnelSize) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateScatteredPattern(targetRow) {
            // 랜덤하게 50-70% 정도 채움
            const fillRate = 0.5 + Math.random() * 0.2;

            for (let col = 0; col < COLS; col++) {
                if (Math.random() < fillRate) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateZigzagPattern(targetRow, index) {
            // 지그재그 형태로 배치
            const direction = index % 2 === 0 ? 1 : -1;

            for (let col = 0; col < COLS; col++) {
                const height = Math.sin((col * Math.PI * 2) / COLS) * direction;
                if (height > 0) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generatePlatformPattern(targetRow) {
            // 중간에 큰 공간을 둔 플랫폼
            const platformSize = 3 + Math.floor(Math.random() * 3); // 3-5칸 공간
            const platformStart = Math.floor((COLS - platformSize) / 2);

            // 양쪽에만 블록 배치
            for (let col = 0; col < platformStart; col++) {
                if (Math.random() < 0.8) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }

            for (let col = platformStart + platformSize; col < COLS; col++) {
                if (Math.random() < 0.8) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function showLevelTransition(newLevel) {
            const transitionElement = document.getElementById('levelTransition');
            const levelNumberElement = document.getElementById('nextLevelNumber');

            levelNumberElement.textContent = `Level ${newLevel}`;
            transitionElement.classList.add('show');

            // Pause game during transition
            isPaused = true;

            // Clear all blocks from the board when advancing to next level
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));

            // Generate obstacles for the new level
            generateObstacles(newLevel);

            setTimeout(() => {
                transitionElement.classList.remove('show');
                isPaused = false;
                lastTime = performance.now();
                update();
            }, 2000);
        }

        function clearLines() {
            let linesToClear = [];

            // 터뜨릴 라인들 찾기
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }

            if (linesToClear.length > 0) {
                // 터지는 애니메이션 실행
                playExplosionAnimation(linesToClear, () => {
                    // 애니메이션 완료 후 실제 라인 제거
                    const linesCleared = linesToClear.length;

                    // 라인 제거
                    linesToClear.sort((a, b) => a - b); // 위에서부터 제거
                    linesToClear.forEach(lineIndex => {
                        board.splice(lineIndex, 1);
                        board.unshift(Array(COLS).fill(0));
                    });

                    lines += linesCleared;
                    const oldLevel = level;
                    score += [0, 50, 150, 250, 400][linesCleared] * level;

                    // Show line clear effect
                    if (linesCleared >= 2) {
                        showLineClearEffect(linesCleared);

                        // Play special sounds for multi-line clears
                        switch(linesCleared) {
                            case 2:
                                playSound('good');
                                break;
                            case 3:
                                playSound('excellent');
                                break;
                            case 4:
                                playSound('great');
                                break;
                        }
                    } else {
                        playSound('clear');
                    }

                    // Calculate new level based on score
                    level = calculateLevel(score);
                    nextLevelScore = getNextLevelScore(level);
                    dropInterval = calculateDropSpeed(level);

                    // Show level transition if level increased
                    if (level > oldLevel) {
                        showLevelTransition(level);
                        playSound('levelUp');
                    }

                    updateScore();
                });
            }
        }

        function playExplosionAnimation(linesToClear, callback) {
            const explosionDuration = 700; // 0.7초로 증가 (깜빡임 추가)
            const startTime = performance.now();
            let animationPhase = 0; // 0: 팽창, 1: 깜빡임, 2: 폭발, 3: 완료

            function animateExplosion(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = elapsed / explosionDuration;

                if (progress < 0.15) {
                    // 1단계: 블록들이 살짝 팽창 (0~0.15초)
                    animationPhase = 0;
                    const scaleProgress = progress / 0.15;
                    const scale = 1 + scaleProgress * 0.3; // 1.0 → 1.3배
                    drawBoard();
                    drawExpandingBlocks(linesToClear, scale);
                } else if (progress < 0.35) {
                    // 2단계: 격렬한 깜빡임 (0.15~0.35초)
                    animationPhase = 1;
                    const flashElapsed = elapsed - (explosionDuration * 0.15);
                    const flashIntensity = Math.sin(flashElapsed * 25) > 0 ? 1 : 0.2; // 빠른 깜빡임
                    drawBoard();
                    drawExpandingBlocks(linesToClear, 1.3); // 최대 크기 유지
                    drawIntenseFlash(linesToClear, flashIntensity);
                } else if (progress < 0.55) {
                    // 3단계: 순간적 대폭발 (0.35~0.55초)
                    if (animationPhase === 1) {
                        animationPhase = 2;
                        createBalloonPopParticles(linesToClear);
                    }
                    const flashProgress = (progress - 0.35) / 0.2;
                    drawBoard();
                    drawMegaExplosionFlash(linesToClear, 1 - flashProgress);
                    drawBalloonPopParticles(flashProgress);
                } else {
                    // 4단계: 파티클 마무리 및 종료 (0.55초 이후)
                    if (progress < 1.0) {
                        const particleProgress = (progress - 0.55) / 0.45;
                        drawBoard();
                        drawBalloonPopParticles(particleProgress);
                    } else {
                        // 애니메이션 완료
                        drawBoard();
                        drawPiece();
                        callback();
                        return;
                    }
                }

                drawPiece();
                requestAnimationFrame(animateExplosion);
            }

            requestAnimationFrame(animateExplosion);
        }

        let balloonPopParticles = [];

        function drawExpandingBlocks(linesToClear, scale) {
            // 터질 블록들을 확대해서 그리기 (풍선 부풀리는 효과)
            ctx.save();
            linesToClear.forEach(row => {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] !== 0) {
                        const centerX = col * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const centerY = row * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const scaledSize = BLOCK_SIZE * scale;

                        // 확대된 블록 그리기
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.scale(scale, scale);
                        ctx.translate(-BLOCK_SIZE / 2, -BLOCK_SIZE / 2);

                        // 원래 블록보다 밝게
                        const color = COLORS[board[row][col]];
                        ctx.fillStyle = color;
                        ctx.fillRect(0, 0, BLOCK_SIZE, BLOCK_SIZE);

                        // 하이라이트 효과
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(0, 0, BLOCK_SIZE, BLOCK_SIZE);

                        ctx.restore();
                    }
                }
            });
            ctx.restore();
        }

        function createBalloonPopParticles(linesToClear) {
            balloonPopParticles = [];

            linesToClear.forEach(row => {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] !== 0) {
                        const centerX = col * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const centerY = row * BLOCK_SIZE + BLOCK_SIZE / 2;

                        // 각 블록마다 8방향으로 파티클 생성 (팡! 터지는 효과)
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const speed = 4 + Math.random() * 6;

                            balloonPopParticles.push({
                                x: centerX,
                                y: centerY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                color: COLORS[board[row][col]],
                                size: 3 + Math.random() * 4,
                                life: 1.0,
                                maxLife: 1.0
                            });
                        }

                        // 추가로 작은 잔해 파티클들
                        for (let i = 0; i < 5; i++) {
                            balloonPopParticles.push({
                                x: centerX + (Math.random() - 0.5) * BLOCK_SIZE,
                                y: centerY + (Math.random() - 0.5) * BLOCK_SIZE,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8,
                                color: COLORS[board[row][col]],
                                size: 1 + Math.random() * 3,
                                life: 1.0,
                                maxLife: 1.0
                            });
                        }
                    }
                }
            });
        }

        function drawIntenseFlash(linesToClear, intensity) {
            // 격렬한 깜빡임 (팽창 후 폭발 직전)
            ctx.fillStyle = `rgba(255, 255, 0, ${intensity * 0.7})`; // 노란색 깜빡임
            linesToClear.forEach(row => {
                ctx.fillRect(0, row * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
            });

            // 추가 화이트 오버레이
            ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.5})`;
            linesToClear.forEach(row => {
                ctx.fillRect(0, row * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
            });
        }

        function drawMegaExplosionFlash(linesToClear, intensity) {
            // 대폭발 순간 - 화면 전체가 밝아짐
            if (intensity > 0.5) {
                // 전체 화면 플래시
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // 터진 라인 특별 효과
            ctx.fillStyle = `rgba(255, 200, 0, ${intensity})`;
            linesToClear.forEach(row => {
                // 라인 확장 효과
                const expand = intensity * 10;
                ctx.fillRect(-expand, row * BLOCK_SIZE - expand,
                           canvas.width + expand * 2, BLOCK_SIZE + expand * 2);
            });
        }

        function drawBalloonPopParticles(progress) {
            ctx.save();

            balloonPopParticles.forEach(particle => {
                if (particle.life > 0) {
                    // 파티클 위치 업데이트
                    particle.x += particle.vx;
                    particle.y += particle.vy;

                    // 마찰로 속도 감소
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;

                    // 생명력 감소
                    particle.life -= 0.025;

                    // 파티클 그리기
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;

                    // 크기가 점점 작아짐
                    const currentSize = particle.size * (particle.life / particle.maxLife);
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();

                    // 흰색 하이라이트
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, currentSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();

            // 죽은 파티클 제거
            balloonPopParticles = balloonPopParticles.filter(p => p.life > 0);
        }

        function drop() {
            if (collision(currentPiece, currentX, currentY + 1)) {
                merge();
                playSound('drop');
                clearLines();
                spawnPiece();
            } else {
                currentY++;
            }
        }

        function hardDrop() {
            while (!collision(currentPiece, currentX, currentY + 1)) {
                currentY++;
            }
            merge();
            playSound('drop');
            clearLines();
            spawnPiece();
        }

        function moveLeft() {
            if (!collision(currentPiece, currentX - 1, currentY)) {
                currentX--;
                playSound('move');
            }
        }

        function moveRight() {
            if (!collision(currentPiece, currentX + 1, currentY)) {
                currentX++;
                playSound('move');
            }
        }

        function rotatePiece() {
            const rotated = rotate(currentPiece);
            if (!collision(rotated, currentX, currentY)) {
                currentPiece = rotated;
                playSound('rotate');
            } else if (!collision(rotated, currentX + 1, currentY)) {
                currentX++;
                currentPiece = rotated;
                playSound('rotate');
            } else if (!collision(rotated, currentX - 1, currentY)) {
                currentX--;
                currentPiece = rotated;
                playSound('rotate');
            }
        }

        function spawnPiece() {
            currentPiece = nextPiece || createPiece();
            nextPiece = createPiece();
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
            currentY = -1;
            
            if (collision(currentPiece, currentX, currentY)) {
                gameOver();
            }
            
            drawNextPiece();
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;

            // Update next level requirement
            if (level >= LEVEL_THRESHOLDS.length) {
                document.getElementById('nextLevel').textContent = "최고 레벨!";
            } else {
                const remaining = nextLevelScore - score;
                document.getElementById('nextLevel').textContent = `다음: ${remaining}점 남음`;
            }
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(gameLoop);
            stopBackgroundMusic();
            playSound('gameOver');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').classList.add('show');
        }

        function togglePause() {
            if (isGameOver) return;
            
            isPaused = !isPaused;
            document.getElementById('pauseIndicator').classList.toggle('show', isPaused);
            
            if (!isPaused) {
                lastTime = performance.now();
                update();
            }
        }

        function restartGame() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
            score = 0;
            level = 1;
            lines = 0;
            nextLevelScore = 500;
            dropInterval = 1000;
            isPaused = false;
            isGameOver = false;
            gameStartTime = performance.now(); // 게임 시작 시간 초기화
            timeSpeedBonus = 0;                // 시간 보너스 초기화

            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('pauseIndicator').classList.remove('show');

            // 게임 시작 시에는 장애물 없음 (레벨 1이므로)
            updateScore();
            nextPiece = createPiece();
            spawnPiece();
            lastTime = performance.now();
            update();
        }

        function update(time = 0) {
            if (isPaused || isGameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            // 시간에 따른 속도 업데이트 (5초마다 한 번씩)
            if (Math.floor(time / 5000) > Math.floor((time - deltaTime) / 5000)) {
                dropInterval = calculateDropSpeed(level);
            }

            if (dropCounter > dropInterval) {
                drop();
                dropCounter = 0;
            }

            drawBoard();
            drawPiece();

            gameLoop = requestAnimationFrame(update);
        }

        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;

            // 테트리스 조작키만 처리하고 다른 키는 기본 동작 허용
            const tetrisKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'p', 'P'];

            if (!tetrisKeys.includes(e.key)) return;

            // 테트리스 키는 기본 동작 방지
            e.preventDefault();

            if (e.key === 'p' || e.key === 'P') {
                togglePause();
                return;
            }

            if (isPaused) return;

            switch(e.key) {
                case 'ArrowLeft':
                    moveLeft();
                    break;
                case 'ArrowRight':
                    moveRight();
                    break;
                case 'ArrowDown':
                    drop();
                    dropCounter = 0;
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ':
                    hardDrop();
                    dropCounter = 0;
                    break;
            }

            drawBoard();
            drawPiece();
        });

        updateScore();
        gameStartTime = performance.now(); // 초기 게임 시작 시간 설정
        nextPiece = createPiece();
        spawnPiece();
        lastTime = performance.now();
        update();
    </script>
</body>
</html>