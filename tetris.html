<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í…ŒíŠ¸ë¦¬ìŠ¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            overflow: hidden;
        }

        .game-header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
            z-index: 10;
            position: relative;
            padding-bottom: 20px;
        }

        .game-header h1 {
            font-size: 48px;
            font-weight: bold;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            user-select: none;
            pointer-events: none;
        }

        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .game-header p {
            font-size: 18px;
            margin: 10px 0 0 0;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-container {
            display: grid;
            grid-template-columns: 250px auto 250px;
            gap: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(255, 255, 255, 0.15);
            align-items: start;
            transform: scale(1.05);
            max-width: 90vw;
        }

        .game-board {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
        }

        canvas {
            display: block;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: #000;
            outline: none;
        }

        canvas:focus {
            outline: none;
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 18px;
            width: 250px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            color: white;
            min-height: 80px;
        }

        .info-box h2 {
            font-size: 20px;
            margin-bottom: 12px;
            text-align: center;
            color: #fff;
        }

        .score-value, .level-value, .lines-value {
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            margin: 12px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .next-level {
            font-size: 14px;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        .next-piece {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            color: white;
            font-size: 15px;
        }

        .controls h3 {
            margin-bottom: 8px;
            text-align: center;
            font-size: 14px;
        }

        .controls p {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .audio-controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            color: white;
            font-size: 15px;
            box-sizing: border-box;
        }

        .audio-controls h3 {
            margin-bottom: 10px;
            text-align: center;
            font-size: 14px;
        }

        .audio-controls label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }

        .audio-controls input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .audio-controls button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .audio-controls button:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
            width: 100%;
        }

        .toggle-label {
            color: white;
            font-size: 15px;
            font-weight: 500;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.3);
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #4CAF50;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .audio-controls select {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .audio-controls input[type="file"] {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            cursor: pointer;
        }

        .audio-controls input[type="file"]::file-selector-button {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 10px;
        }

        .controls kbd {
            background: rgba(0, 0, 0, 0.3);
            padding: 3px 8px;
            border-radius: 3px;
            font-family: monospace;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over.show {
            display: block;
        }

        .game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .game-over button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-over button:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            display: none;
        }

        .pause-indicator.show {
            display: block;
        }

        .line-clear-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 500;
            animation: effectPulse 1.5s ease-out;
        }

        .line-clear-effect.show {
            display: block;
        }

        .line-clear-effect.good {
            color: #4CAF50;
            text-shadow: 0 0 10px #4CAF50;
        }

        .line-clear-effect.excellent {
            color: #2196F3;
            text-shadow: 0 0 15px #2196F3;
        }

        .line-clear-effect.great {
            color: #FF9800;
            text-shadow: 0 0 20px #FF9800;
        }

        @keyframes effectPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .level-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 48px;
            font-weight: bold;
            display: none;
            z-index: 1000;
        }

        .level-transition.show {
            display: flex;
        }

        .level-transition h1 {
            font-size: 64px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 0 0 20px #FFD700;
        }

        .level-transition p {
            font-size: 36px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>ë‘ë‡Œë°œë‹¬ í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„</h1>
        <p>ğŸ§  Brain Training Tetris - 50 Levels Challenge ğŸ®</p>
    </div>
    <div class="game-container">
        <div class="left-panel">
            <div class="info-box">
                <h2>ì ìˆ˜</h2>
                <div class="score-value" id="score">0</div>
            </div>

            <div class="info-box">
                <h2>ë ˆë²¨</h2>
                <div class="level-value" id="level">1</div>
                <div class="next-level" id="nextLevel">ë‹¤ìŒ: 500ì </div>
            </div>

            <div class="info-box">
                <h2>ë¼ì¸</h2>
                <div class="lines-value" id="lines">0</div>
            </div>

            <div class="controls">
                <h3>ì¡°ì‘ë²•</h3>
                <p><span>ì¢Œìš° ì´ë™</span><kbd>â†</kbd> <kbd>â†’</kbd></p>
                <p><span>íšŒì „</span><kbd>â†‘</kbd></p>
                <p><span>ë¹ ë¥¸ ë‚™í•˜</span><kbd>â†“</kbd></p>
                <p><span>ì¦‰ì‹œ ë‚™í•˜</span><kbd>Space</kbd></p>
                <p><span>ì¼ì‹œì •ì§€</span><kbd>P</kbd></p>
            </div>
        </div>

        <div class="game-board">
            <canvas id="tetris" width="400" height="800"></canvas>
            <div class="pause-indicator" id="pauseIndicator">ì¼ì‹œì •ì§€</div>
            <div class="line-clear-effect" id="lineClearEffect">GOOD!</div>
        </div>

        <div class="right-panel">
            <div class="info-box">
                <h2>ë‹¤ìŒ ë¸”ë¡</h2>
                <canvas id="nextPiece" width="160" height="160" class="next-piece"></canvas>
            </div>

            <div class="audio-controls">
                <h3>ìŒì•… ì„¤ì •</h3>
                <label>
                    ìŒì•… íŒŒì¼:
                    <input type="file" id="musicFile" accept="audio/*" onchange="loadCustomMusic()">
                </label>
                <div id="recentMusicList" style="display: none;">
                    <label>ìµœê·¼ ì‚¬ìš©í•œ ìŒì•…:</label>
                    <select id="recentMusic" onchange="loadRecentMusic()">
                        <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                    </select>
                </div>
                <label>
                    ë³¼ë¥¨: <span id="musicVolumeLabel">30%</span>
                    <input type="range" id="musicVolume" min="0" max="100" value="30" oninput="changeMusicVolume()">
                </label>
                <div class="toggle-switch">
                    <span class="toggle-label">ìŒì•…</span>
                    <label class="switch">
                        <input type="checkbox" id="musicToggle" onchange="toggleBackgroundMusic()">
                        <span class="slider"></span>
                    </label>
                </div>
                <button onclick="clearRecentMusic()" style="background: rgba(255, 0, 0, 0.3); margin-top: 5px;">ìµœê·¼ ìŒì•… ì‚­ì œ</button>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h1>ê²Œì„ ì˜¤ë²„</h1>
        <p style="font-size: 24px; margin: 20px 0;">ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <div class="level-transition" id="levelTransition">
        <h1>CLEAR!</h1>
        <p>Next Level</p>
        <p id="nextLevelNumber">Level 2</p>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextPiece');
        const nextCtx = nextCanvas.getContext('2d');

        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 40;

        const COLORS = [
            '#000000',
            '#00ffff', // I-piece - Cyan
            '#0000ff', // J-piece - Blue
            '#ff8c00', // L-piece - Orange
            '#ffff00', // O-piece - Yellow
            '#00ff00', // S-piece - Green
            '#800080', // T-piece - Purple
            '#ff0000'  // Z-piece - Red
        ];

        // Sound system with single AudioContext for stability
        let audioContext = null;
        let soundEnabled = true;
        let backgroundMusic = null;
        let musicGain = null;
        let musicVolume = 0.3;
        let musicEnabled = false;
        let customAudio = null;
        let isCustomMusicPlaying = false;
        let recentMusicList = [];
        let lastUsedMusic = null;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                return true;
            } catch (e) {
                soundEnabled = false;
                return false;
            }
        }

        function startBackgroundMusic() {
            if (!musicEnabled || !customAudio) {
                console.log('Cannot start music:', 'enabled:', musicEnabled, 'audio:', !!customAudio);
                return;
            }

            try {
                customAudio.volume = musicVolume;
                customAudio.currentTime = 0;

                const playPromise = customAudio.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        isCustomMusicPlaying = true;
                        console.log('Music started successfully');
                    }).catch(e => {
                        console.log('Auto-play blocked, waiting for user interaction:', e.message);

                        // ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ëŒ€ê¸°
                        const playOnInteraction = () => {
                            if (musicEnabled && customAudio) {
                                customAudio.play().then(() => {
                                    isCustomMusicPlaying = true;
                                    console.log('Music started after user interaction');
                                }).catch(err => console.log('User interaction play failed:', err));
                            }
                        };

                        // ê²Œì„ ì¡°ì‘ìœ¼ë¡œë„ ìŒì•… ì‹œì‘ ê°€ëŠ¥
                        document.addEventListener('click', playOnInteraction, { once: true });
                        document.addEventListener('keydown', playOnInteraction, { once: true });
                    });
                } else {
                    isCustomMusicPlaying = true;
                }
            } catch (e) {
                console.error('Start music error:', e);
            }
        }

        function stopBackgroundMusic() {
            if (customAudio && isCustomMusicPlaying) {
                customAudio.pause();
                isCustomMusicPlaying = false;
            }
        }


        function saveToRecentMusic(fileName, audioData) {
            // íŒŒì¼ í¬ê¸° ì²´í¬ (10MB ì´ìƒì´ë©´ ì €ì¥ ì•ˆí•¨)
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (audioData.length > maxSize) {
                console.log('File too large for storage, skipping recent music save');
                alert('íŒŒì¼ì´ ë„ˆë¬´ ì»¤ì„œ ìµœê·¼ ìŒì•… ëª©ë¡ì— ì €ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (10MB ì œí•œ)');
                return;
            }

            try {
                // ìµœê·¼ ìŒì•… ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (ìµœëŒ€ 3ê°œë¡œ ì¤„ì„)
                const musicItem = { name: fileName, data: audioData, timestamp: Date.now() };

                // ê°™ì€ íŒŒì¼ì´ ì´ë¯¸ ìˆìœ¼ë©´ ì œê±°
                recentMusicList = recentMusicList.filter(item => item.name !== fileName);

                // ë§¨ ì•ì— ì¶”ê°€
                recentMusicList.unshift(musicItem);

                // ìµœëŒ€ 3ê°œê¹Œì§€ë§Œ ìœ ì§€ (ìš©ëŸ‰ ì ˆì•½)
                if (recentMusicList.length > 3) {
                    recentMusicList = recentMusicList.slice(0, 3);
                }

                // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ ì‹œë„
                localStorage.setItem('tetrisRecentMusic', JSON.stringify(recentMusicList));
                localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(musicItem));

                console.log('Music saved to recent list');
                // UI ì—…ë°ì´íŠ¸
                updateRecentMusicUI();
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.log('Storage quota exceeded, clearing old music');
                    alert('ì €ì¥ ê³µê°„ì´ ë¶€ì¡±í•´ì„œ ì´ì „ ìŒì•…ë“¤ì„ ì‚­ì œí•©ë‹ˆë‹¤.');

                    // ê¸°ì¡´ ìŒì•… ëª¨ë‘ ì‚­ì œ
                    recentMusicList = [];
                    localStorage.removeItem('tetrisRecentMusic');
                    localStorage.removeItem('tetrisLastUsedMusic');

                    // í˜„ì¬ ìŒì•…ë§Œ ì €ì¥ (íŒŒì¼ì´ ì‘ìœ¼ë©´)
                    if (audioData.length <= maxSize) {
                        try {
                            const musicItem = { name: fileName, data: audioData, timestamp: Date.now() };
                            recentMusicList = [musicItem];
                            localStorage.setItem('tetrisRecentMusic', JSON.stringify(recentMusicList));
                            localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(musicItem));
                        } catch (e2) {
                            console.log('Still too large, skipping storage');
                        }
                    }

                    updateRecentMusicUI();
                } else {
                    console.error('Storage error:', e);
                }
            }
        }

        function loadRecentMusicList() {
            try {
                const saved = localStorage.getItem('tetrisRecentMusic');
                if (saved) {
                    recentMusicList = JSON.parse(saved);
                    updateRecentMusicUI();
                }
            } catch (e) {
                recentMusicList = [];
            }
        }

        function updateRecentMusicUI() {
            const recentMusicDiv = document.getElementById('recentMusicList');
            const recentMusicSelect = document.getElementById('recentMusic');

            if (recentMusicList.length > 0) {
                recentMusicDiv.style.display = 'block';
                recentMusicSelect.innerHTML = '<option value="">ì„ íƒí•˜ì„¸ìš”</option>';

                recentMusicList.forEach((item, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    // íŒŒì¼ëª…ì´ ê¸¸ë©´ ì¤„ì„
                    const shortName = item.name.length > 30 ? item.name.substring(0, 30) + '...' : item.name;
                    option.textContent = shortName;
                    option.title = item.name; // ì „ì²´ ì´ë¦„ì€ íˆ´íŒìœ¼ë¡œ
                    recentMusicSelect.appendChild(option);
                });
            } else {
                recentMusicDiv.style.display = 'none';
            }
        }

        function loadRecentMusic() {
            const select = document.getElementById('recentMusic');
            const index = parseInt(select.value);

            if (index >= 0 && index < recentMusicList.length) {
                const musicItem = recentMusicList[index];
                loadMusicFromData(musicItem.name, musicItem.data);
            }
        }

        function loadMusicFromData(fileName, audioData) {
            console.log('Loading music:', fileName);

            // Stop current music
            stopBackgroundMusic();

            // Create new audio element
            if (customAudio) {
                customAudio.pause();
                customAudio.src = '';
                customAudio = null;
            }

            try {
                customAudio = new Audio(audioData);
                customAudio.loop = true;
                customAudio.volume = musicVolume;

                // ìŒì•… ë¡œë“œ ì™„ë£Œ í›„ ì²˜ë¦¬
                customAudio.addEventListener('canplay', () => {
                    console.log('Audio can play');
                    // í† ê¸€ ìŠ¤ìœ„ì¹˜ ì¼œê¸°
                    const toggle = document.getElementById('musicToggle');
                    toggle.checked = true;
                    musicEnabled = true;

                    // ì¦‰ì‹œ ì¬ìƒ ì‹œë„
                    startBackgroundMusic();
                });

                customAudio.addEventListener('error', (e) => {
                    console.error('Audio load error:', e);
                });

                // ìµœê·¼ ì‚¬ìš© ìŒì•… ì—…ë°ì´íŠ¸
                lastUsedMusic = { name: fileName, data: audioData };
                localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(lastUsedMusic));

            } catch (e) {
                console.error('Failed to create audio:', e);
            }
        }

        function autoPlayLastMusic() {
            try {
                const lastMusic = localStorage.getItem('tetrisLastUsedMusic');
                if (lastMusic) {
                    lastUsedMusic = JSON.parse(lastMusic);
                    console.log('Loading last used music:', lastUsedMusic.name);

                    // ì¦‰ì‹œ ë¡œë“œ (ì¬ìƒì€ ì‚¬ìš©ìê°€ í† ê¸€ë¡œ ì œì–´)
                    if (lastUsedMusic) {
                        // ìŒì•… íŒŒì¼ ë¡œë“œë§Œ í•˜ê³  ìë™ ì¬ìƒí•˜ì§€ ì•ŠìŒ
                        if (customAudio) {
                            customAudio.pause();
                            customAudio = null;
                        }

                        customAudio = new Audio(lastUsedMusic.data);
                        customAudio.loop = true;
                        customAudio.volume = musicVolume;

                        console.log('Last music loaded, waiting for user to enable toggle');
                    }
                }
            } catch (e) {
                console.log('Failed to load last used music:', e);
            }
        }

        function clearRecentMusic() {
            recentMusicList = [];
            lastUsedMusic = null;
            localStorage.removeItem('tetrisRecentMusic');
            localStorage.removeItem('tetrisLastUsedMusic');
            updateRecentMusicUI();
            stopBackgroundMusic();
            musicEnabled = false;
        }

        function loadCustomMusic() {
            const fileInput = document.getElementById('musicFile');
            const file = fileInput.files[0];

            if (file) {
                console.log('Loading file:', file.name);
                const reader = new FileReader();
                reader.onload = function(e) {
                    const audioData = e.target.result;
                    console.log('File read complete, size:', audioData.length);

                    // ìµœê·¼ ìŒì•… ë¦¬ìŠ¤íŠ¸ì— ì €ì¥
                    saveToRecentMusic(file.name, audioData);

                    // ì§ì ‘ ìŒì•… ìƒì„± ë° ì¬ìƒ
                    createAndPlayMusic(file.name, audioData);
                };
                reader.readAsDataURL(file);
            }
        }

        function createAndPlayMusic(fileName, audioData) {
            console.log('Creating audio for:', fileName);

            // Stop current music
            stopBackgroundMusic();

            // Create new audio element
            if (customAudio) {
                customAudio.pause();
                customAudio.src = '';
                customAudio = null;
            }

            try {
                customAudio = new Audio(audioData);
                customAudio.loop = true;
                customAudio.volume = musicVolume;

                // í† ê¸€ ìŠ¤ìœ„ì¹˜ ì¼œê¸°
                const toggle = document.getElementById('musicToggle');
                toggle.checked = true;
                musicEnabled = true;

                // ì¦‰ì‹œ ì¬ìƒ ì‹œë„ (ì‚¬ìš©ì ì œìŠ¤ì²˜ í•„ìš”)
                console.log('Attempting to play music...');
                customAudio.play().then(() => {
                    isCustomMusicPlaying = true;
                    console.log('Music playing successfully!');
                }).catch(e => {
                    console.log('Need user interaction to play:', e.message);

                    // ì•Œë¦¼ í‘œì‹œ
                    alert('ìŒì•…ì„ ì¬ìƒí•˜ë ¤ë©´ í™”ë©´ì„ í´ë¦­í•˜ê±°ë‚˜ í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”.');

                    // ë‹¤ìŒ í´ë¦­/í‚¤ ì…ë ¥ì—ì„œ ì¬ìƒ
                    const playOnClick = () => {
                        customAudio.play().then(() => {
                            isCustomMusicPlaying = true;
                            console.log('Music started after user interaction');
                        }).catch(err => console.log('Still failed:', err));
                    };

                    document.addEventListener('click', playOnClick, { once: true });
                    document.addEventListener('keydown', playOnClick, { once: true });
                });

                // ìµœê·¼ ì‚¬ìš© ìŒì•… ì—…ë°ì´íŠ¸
                lastUsedMusic = { name: fileName, data: audioData };
                localStorage.setItem('tetrisLastUsedMusic', JSON.stringify(lastUsedMusic));

            } catch (e) {
                console.error('Failed to create audio:', e);
            }
        }

        function changeMusicVolume() {
            const slider = document.getElementById('musicVolume');
            const label = document.getElementById('musicVolumeLabel');
            musicVolume = slider.value / 100;
            label.textContent = slider.value + '%';

            // Update custom audio volume
            if (customAudio) {
                customAudio.volume = musicVolume;
            }
        }

        function toggleBackgroundMusic() {
            const toggle = document.getElementById('musicToggle');
            musicEnabled = toggle.checked;

            console.log('Music toggle:', musicEnabled, 'Has audio:', !!customAudio);

            if (musicEnabled && customAudio) {
                startBackgroundMusic();
            } else {
                stopBackgroundMusic();
            }
        }

        function createSound(frequency, duration, type = 'sine', volume = 0.3) {
            if (!soundEnabled || !audioContext) return;

            try {
                // Resume context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Silent fail
            }
        }

        function playSound(soundType) {
            if (!soundEnabled) return;

            try {
                switch(soundType) {
                    case 'move':
                        createSound(200, 0.1, 'sine', 0.2);
                        break;
                    case 'rotate':
                        createSound(300, 0.15, 'sine', 0.25);
                        break;
                    case 'drop':
                        createSound(150, 0.2, 'sine', 0.3);
                        break;
                    case 'clear':
                        setTimeout(() => createSound(500, 0.2, 'sine', 0.4), 0);
                        setTimeout(() => createSound(600, 0.2, 'sine', 0.4), 100);
                        setTimeout(() => createSound(700, 0.3, 'sine', 0.4), 200);
                        break;
                    case 'good':
                        // 2ì¤„ - ê°•ë ¬í•œ ë”ë¸” ì„íŒ©íŠ¸
                        setTimeout(() => createSound(300, 0.1, 'sawtooth', 0.6), 0);
                        setTimeout(() => createSound(500, 0.15, 'square', 0.7), 50);
                        setTimeout(() => createSound(700, 0.2, 'sine', 0.6), 150);
                        setTimeout(() => createSound(400, 0.25, 'triangle', 0.5), 300);
                        break;
                    case 'excellent':
                        // 3ì¤„ - íŠ¸ë¦¬í”Œ ì½¤ë³´ ì‚¬ìš´ë“œ
                        setTimeout(() => createSound(350, 0.1, 'sawtooth', 0.7), 0);
                        setTimeout(() => createSound(200, 0.1, 'square', 0.6), 50);
                        setTimeout(() => createSound(600, 0.12, 'sine', 0.8), 100);
                        setTimeout(() => createSound(450, 0.12, 'triangle', 0.7), 180);
                        setTimeout(() => createSound(750, 0.15, 'square', 0.8), 250);
                        setTimeout(() => createSound(850, 0.2, 'sine', 0.7), 350);
                        break;
                    case 'great':
                        // 4ì¤„ - ë©”ê°€ í­ë°œ ì‚¬ìš´ë“œ
                        setTimeout(() => createSound(150, 0.15, 'sawtooth', 0.8), 0);
                        setTimeout(() => createSound(400, 0.1, 'square', 0.9), 30);
                        setTimeout(() => createSound(250, 0.1, 'sawtooth', 0.7), 60);
                        setTimeout(() => createSound(700, 0.12, 'sine', 0.9), 100);
                        setTimeout(() => createSound(500, 0.1, 'triangle', 0.8), 150);
                        setTimeout(() => createSound(900, 0.15, 'square', 0.9), 200);
                        setTimeout(() => createSound(650, 0.12, 'sine', 0.8), 270);
                        setTimeout(() => createSound(1100, 0.3, 'triangle', 0.9), 350);
                        break;
                    case 'levelUp':
                        setTimeout(() => createSound(400, 0.15, 'sine', 0.5), 0);
                        setTimeout(() => createSound(500, 0.15, 'sine', 0.5), 100);
                        setTimeout(() => createSound(600, 0.15, 'sine', 0.5), 200);
                        setTimeout(() => createSound(700, 0.2, 'sine', 0.5), 300);
                        break;
                    case 'gameOver':
                        createSound(100, 0.8, 'sawtooth', 0.3);
                        break;
                }
            } catch (e) {
                // Silent fail
            }
        }

        // Initialize audio on first user interaction
        function enableAudio() {
            if (!audioContext) {
                initAudio();
            }
        }

        // Auto-initialize audio when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Try to initialize audio immediately
            initAudio();
            // Load recent music list and auto-play last used music
            loadRecentMusicList();
            autoPlayLastMusic();
        });

        // Also try when user first interacts with the page
        document.addEventListener('click', enableAudio, { once: true });
        document.addEventListener('keydown', enableAudio, { once: true });

        // Calculate current level based on score
        function calculateLevel(currentScore) {
            for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
                if (currentScore >= LEVEL_THRESHOLDS[i]) {
                    return i + 1;
                }
            }
            return 1;
        }

        // Get next level score requirement
        function getNextLevelScore(currentLevel) {
            if (currentLevel < LEVEL_THRESHOLDS.length) {
                return LEVEL_THRESHOLDS[currentLevel];
            }
            return LEVEL_THRESHOLDS[LEVEL_THRESHOLDS.length - 1];
        }

        // Calculate drop speed based on level and time
        function calculateDropSpeed(currentLevel) {
            // ë ˆë²¨ì´ ë†’ì•„ì§ˆìˆ˜ë¡ ë” ë¹¨ë¼ì§ (ìµœì†Œ 50ms, ìµœëŒ€ 1000ms)
            const baseSpeed = 1000;
            const levelSpeedReduction = (currentLevel - 1) * 80;

            // ì‹œê°„ì— ë”°ë¥¸ ì ì§„ì  ì†ë„ ì¦ê°€ (30ì´ˆë§ˆë‹¤ 5msì”© ë¹¨ë¼ì§)
            const currentTime = performance.now();
            const elapsedSeconds = (currentTime - gameStartTime) / 1000;
            timeSpeedBonus = Math.floor(elapsedSeconds / 30) * 5; // 30ì´ˆë§ˆë‹¤ 5ms ë¹¨ë¼ì§

            const finalSpeed = baseSpeed - levelSpeedReduction - timeSpeedBonus;
            return Math.max(50, finalSpeed);
        }

        // Level progression system - score requirements for each level (50ë‹¨ê³„ê¹Œì§€ í™•ì¥)
        const LEVEL_THRESHOLDS = [
            0,        // Level 1: 0ì 
            500,      // Level 2: 500ì 
            1200,     // Level 3: 1200ì 
            2500,     // Level 4: 2500ì 
            4500,     // Level 5: 4500ì 
            7000,     // Level 6: 7000ì 
            10000,    // Level 7: 10000ì 
            14000,    // Level 8: 14000ì 
            19000,    // Level 9: 19000ì 
            25000,    // Level 10: 25000ì 
            32000,    // Level 11: 32000ì 
            40000,    // Level 12: 40000ì 
            50000,    // Level 13: 50000ì 
            62000,    // Level 14: 62000ì 
            76000,    // Level 15: 76000ì 
            92000,    // Level 16: 92000ì 
            110000,   // Level 17: 110000ì 
            130000,   // Level 18: 130000ì 
            155000,   // Level 19: 155000ì 
            200000,   // Level 20: 200000ì 
            250000,   // Level 21: 250000ì 
            310000,   // Level 22: 310000ì 
            380000,   // Level 23: 380000ì 
            460000,   // Level 24: 460000ì 
            550000,   // Level 25: 550000ì 
            650000,   // Level 26: 650000ì 
            760000,   // Level 27: 760000ì 
            880000,   // Level 28: 880000ì 
            1010000,  // Level 29: 1010000ì 
            1150000,  // Level 30: 1150000ì 
            1300000,  // Level 31: 1300000ì 
            1460000,  // Level 32: 1460000ì 
            1630000,  // Level 33: 1630000ì 
            1810000,  // Level 34: 1810000ì 
            2000000,  // Level 35: 2000000ì 
            2200000,  // Level 36: 2200000ì 
            2410000,  // Level 37: 2410000ì 
            2630000,  // Level 38: 2630000ì 
            2860000,  // Level 39: 2860000ì 
            3100000,  // Level 40: 3100000ì 
            3350000,  // Level 41: 3350000ì 
            3610000,  // Level 42: 3610000ì 
            3880000,  // Level 43: 3880000ì 
            4160000,  // Level 44: 4160000ì 
            4450000,  // Level 45: 4450000ì 
            4750000,  // Level 46: 4750000ì 
            5060000,  // Level 47: 5060000ì 
            5380000,  // Level 48: 5380000ì 
            5710000,  // Level 49: 5710000ì 
            6000000   // Level 50: 6000000ì 
        ];

        const SHAPES = [
            [[1, 1, 1, 1]],
            [[2, 0, 0], [2, 2, 2]],
            [[0, 0, 3], [3, 3, 3]],
            [[4, 4], [4, 4]],
            [[0, 5, 5], [5, 5, 0]],
            [[0, 6, 0], [6, 6, 6]],
            [[7, 7, 0], [0, 7, 7]]
        ];

        let board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let nextPiece = null;
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameLoop = null;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isPaused = false;
        let isGameOver = false;
        let nextLevelScore = 500;  // ë‹¤ìŒ ë ˆë²¨ê¹Œì§€ í•„ìš”í•œ ì ìˆ˜
        let gameStartTime = 0;     // ê²Œì„ ì‹œì‘ ì‹œê°„
        let timeSpeedBonus = 0;    // ì‹œê°„ì— ë”°ë¥¸ ì†ë„ ë³´ë„ˆìŠ¤

        function createPiece() {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            return JSON.parse(JSON.stringify(shape));
        }

        function drawBlock(x, y, color, context = ctx, blockSize = BLOCK_SIZE) {
            const blockX = x * blockSize;
            const blockY = y * blockSize;

            // Main block color
            context.fillStyle = color;
            context.fillRect(blockX, blockY, blockSize, blockSize);

            // Gradient effect
            const gradient = context.createLinearGradient(blockX, blockY, blockX + blockSize, blockY + blockSize);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            context.fillStyle = gradient;
            context.fillRect(blockX, blockY, blockSize, blockSize);

            // Border with rounded corners effect
            context.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            context.lineWidth = 1;
            context.strokeRect(blockX + 1, blockY + 1, blockSize - 2, blockSize - 2);

            context.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            context.lineWidth = 1;
            context.strokeRect(blockX, blockY, blockSize, blockSize);

            // Inner highlight
            context.fillStyle = 'rgba(255, 255, 255, 0.3)';
            context.fillRect(blockX + 2, blockY + 2, blockSize - 8, blockSize - 8);

            // Bottom shadow
            context.fillStyle = 'rgba(0, 0, 0, 0.2)';
            context.fillRect(blockX + 2, blockY + blockSize - 4, blockSize - 4, 2);
        }

        function drawBoard() {
            // Background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }

            // Draw blocks
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, COLORS[board[y][x]]);
                    }
                }
            }
        }

        function drawPiece() {
            if (!currentPiece) return;
            
            for (let y = 0; y < currentPiece.length; y++) {
                for (let x = 0; x < currentPiece[y].length; x++) {
                    if (currentPiece[y][x]) {
                        drawBlock(currentX + x, currentY + y, COLORS[currentPiece[y][x]]);
                    }
                }
            }
        }

        function drawNextPiece() {
            nextCtx.fillStyle = '#000';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (!nextPiece) return;
            
            const offsetX = (4 - nextPiece[0].length) / 2;
            const offsetY = (4 - nextPiece.length) / 2;
            
            for (let y = 0; y < nextPiece.length; y++) {
                for (let x = 0; x < nextPiece[y].length; x++) {
                    if (nextPiece[y][x]) {
                        drawBlock(offsetX + x, offsetY + y, COLORS[nextPiece[y][x]], nextCtx, 40);
                    }
                }
            }
        }

        function collision(piece, x, y) {
            for (let py = 0; py < piece.length; py++) {
                for (let px = 0; px < piece[py].length; px++) {
                    if (piece[py][px]) {
                        const newX = x + px;
                        const newY = y + py;
                        
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        
                        if (newY >= 0 && board[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge() {
            for (let y = 0; y < currentPiece.length; y++) {
                for (let x = 0; x < currentPiece[y].length; x++) {
                    if (currentPiece[y][x]) {
                        if (currentY + y < 0) {
                            gameOver();
                            return;
                        }
                        board[currentY + y][currentX + x] = currentPiece[y][x];
                    }
                }
            }
        }

        function rotate(piece) {
            const rotated = piece[0].map((_, i) => piece.map(row => row[i]).reverse());
            return rotated;
        }

        function showLineClearEffect(linesCleared) {
            const effectElement = document.getElementById('lineClearEffect');
            const effectNames = ['', '', 'GOOD!', 'EXCELLENT!', 'GREAT!'];
            const effectClasses = ['', '', 'good', 'excellent', 'great'];

            effectElement.textContent = effectNames[linesCleared];
            effectElement.className = `line-clear-effect show ${effectClasses[linesCleared]}`;

            setTimeout(() => {
                effectElement.classList.remove('show');
            }, 1500);
        }

        function generateObstacles(level) {
            if (level < 5) return; // 5ë‹¨ê³„ë¶€í„° ì¥ì• ë¬¼ ìƒì„±

            // ë ˆë²¨ì— ë”°ë¥¸ ì¥ì• ë¬¼ íŒ¨í„´ - ê³µì¤‘ ì¥ì• ë¬¼ í¬í•¨
            const obstaclePatterns = {
                5: { total: 2, floating: 1 },   // 5ë‹¨ê³„: ë°”ë‹¥ 1ì¤„ + ê³µì¤‘ 1ì¤„
                10: { total: 3, floating: 1 },  // 10ë‹¨ê³„: ë°”ë‹¥ 2ì¤„ + ê³µì¤‘ 1ì¤„
                15: { total: 4, floating: 2 },  // 15ë‹¨ê³„: ë°”ë‹¥ 2ì¤„ + ê³µì¤‘ 2ì¤„
                20: { total: 5, floating: 2 },  // 20ë‹¨ê³„: ë°”ë‹¥ 3ì¤„ + ê³µì¤‘ 2ì¤„
                25: { total: 6, floating: 3 },  // 25ë‹¨ê³„: ë°”ë‹¥ 3ì¤„ + ê³µì¤‘ 3ì¤„
                30: { total: 7, floating: 3 },  // 30ë‹¨ê³„: ë°”ë‹¥ 4ì¤„ + ê³µì¤‘ 3ì¤„
                35: { total: 8, floating: 4 },  // 35ë‹¨ê³„: ë°”ë‹¥ 4ì¤„ + ê³µì¤‘ 4ì¤„
                40: { total: 9, floating: 4 },  // 40ë‹¨ê³„: ë°”ë‹¥ 5ì¤„ + ê³µì¤‘ 4ì¤„
                45: { total: 10, floating: 5 }, // 45ë‹¨ê³„: ë°”ë‹¥ 5ì¤„ + ê³µì¤‘ 5ì¤„
                50: { total: 12, floating: 6 }  // 50ë‹¨ê³„: ë°”ë‹¥ 6ì¤„ + ê³µì¤‘ 6ì¤„
            };

            // í˜„ì¬ ë ˆë²¨ì— ë§ëŠ” ì¥ì• ë¬¼ íŒ¨í„´ ê³„ì‚°
            let pattern = { total: 0, floating: 0 };
            for (let checkLevel of Object.keys(obstaclePatterns).map(Number).sort((a, b) => b - a)) {
                if (level >= checkLevel) {
                    pattern = obstaclePatterns[checkLevel];
                    break;
                }
            }

            // ë°”ë‹¥ ì¥ì• ë¬¼ ìƒì„±
            const groundRows = pattern.total - pattern.floating;
            for (let row = 0; row < groundRows; row++) {
                const targetRow = ROWS - 1 - row;
                generateObstacleRow(targetRow, row, level, 'ground');
            }

            // ê³µì¤‘ ì¥ì• ë¬¼ ìƒì„± (ê²Œì„ ë³´ë“œ ì¤‘ê°„ ë¶€ë¶„ì—)
            for (let i = 0; i < pattern.floating; i++) {
                // ê³µì¤‘ ì¥ì• ë¬¼ì€ ê²Œì„ ë³´ë“œì˜ ì¤‘ê°„~ìƒë‹¨ ë¶€ë¶„ì— ë°°ì¹˜
                const minRow = 3; // ìµœì†Œ 3í–‰ ì´ìƒì—ì„œ ì‹œì‘
                const maxRow = Math.floor(ROWS * 0.7); // ì „ì²´ ë³´ë“œì˜ 70% ìœ„ì¹˜ê¹Œì§€
                const targetRow = minRow + (i * Math.floor((maxRow - minRow) / Math.max(1, pattern.floating - 1)));

                generateFloatingObstacle(targetRow, i, level);
            }
        }

        function generateObstacleRow(targetRow, rowIndex, level, type = 'ground') {
            // ë ˆë²¨ê³¼ ì¤„ ì¸ë±ìŠ¤ì— ë”°ë¥¸ ë‹¤ì–‘í•œ íŒ¨í„´
            const patternType = (level + rowIndex) % 6;

            switch(patternType) {
                case 0: // ì¢Œìš° ëŒ€ì¹­ íŒ¨í„´
                    generateSymmetricPattern(targetRow);
                    break;
                case 1: // ê³„ë‹¨ íŒ¨í„´
                    generateStairPattern(targetRow, rowIndex);
                    break;
                case 2: // ì¤‘ì•™ ì§‘ì¤‘ íŒ¨í„´
                    generateCenterPattern(targetRow);
                    break;
                case 3: // ì¢Œìš° ë íŒ¨í„´
                    generateSidePattern(targetRow);
                    break;
                case 4: // ì²´ìŠ¤íŒ íŒ¨í„´
                    generateCheckerPattern(targetRow, rowIndex);
                    break;
                case 5: // ëœë¤ íŒ¨í„´ (ê¸°ì¡´)
                    generateRandomPattern(targetRow);
                    break;
            }
        }

        function generateSymmetricPattern(targetRow) {
            // ì¢Œìš° ëŒ€ì¹­ìœ¼ë¡œ ë¸”ë¡ ë°°ì¹˜
            const centerGap = 2 + Math.floor(Math.random() * 3); // 2-4ì¹¸ ê°€ìš´ë° ë¹„ì›€
            const startGap = Math.floor((COLS - centerGap) / 2);

            for (let col = 0; col < COLS; col++) {
                if (col < startGap || col >= startGap + centerGap) {
                    // 80% í™•ë¥ ë¡œ ë¸”ë¡ ë°°ì¹˜
                    if (Math.random() < 0.8) {
                        board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                    }
                }
            }
        }

        function generateStairPattern(targetRow, rowIndex) {
            // ê³„ë‹¨ ëª¨ì–‘ íŒ¨í„´
            const direction = rowIndex % 2 === 0 ? 1 : -1; // ì¢Œìš° ë²ˆê°ˆì•„
            const steps = 3;

            for (let col = 0; col < COLS; col++) {
                const stepPosition = direction > 0 ?
                    Math.floor(col / steps) :
                    Math.floor((COLS - 1 - col) / steps);

                if (stepPosition % 2 === rowIndex % 2) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateCenterPattern(targetRow) {
            // ì¤‘ì•™ì— ì§‘ì¤‘ëœ íŒ¨í„´, ì–‘ìª½ ë ë¹„ì›€
            for (let col = 2; col < COLS - 2; col++) {
                if (Math.random() < 0.85) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateSidePattern(targetRow) {
            // ì–‘ìª½ ëì—ë§Œ ë¸”ë¡, ì¤‘ì•™ ë¹„ì›€
            const sideWidth = 3;

            for (let col = 0; col < sideWidth; col++) {
                if (Math.random() < 0.9) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }

            for (let col = COLS - sideWidth; col < COLS; col++) {
                if (Math.random() < 0.9) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateCheckerPattern(targetRow, rowIndex) {
            // ì²´ìŠ¤íŒ ë¬´ëŠ¬ íŒ¨í„´
            for (let col = 0; col < COLS; col++) {
                if ((col + rowIndex) % 2 === 0) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateRandomPattern(targetRow) {
            // ê¸°ì¡´ ëœë¤ íŒ¨í„´
            const fillRate = 0.6 + Math.random() * 0.2;
            const blocksToFill = Math.floor(COLS * fillRate);

            const positions = Array.from({length: COLS}, (_, i) => i);
            const randomPositions = positions.sort(() => Math.random() - 0.5).slice(0, blocksToFill);

            randomPositions.forEach(col => {
                board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
            });
        }

        function generateFloatingObstacle(targetRow, obstacleIndex, level) {
            // ê³µì¤‘ ì¥ì• ë¬¼ íŒ¨í„´ - ë” ì „ëµì ì¸ ë°°ì¹˜
            const floatingPatterns = [
                'bridge',        // ë‹¤ë¦¬ í˜•íƒœ (ì–‘ìª½ ëë§Œ ë¹„ì›Œë‘ )
                'islands',       // ì„¬ í˜•íƒœ (ì‘ì€ ë¸”ë¡ ë©ì–´ë¦¬ë“¤)
                'tunnel',        // í„°ë„ í˜•íƒœ (ê°€ìš´ë°ë§Œ ë¹„ì›Œë‘ )
                'scattered',     // í©ì–´ì§„ í˜•íƒœ (ëœë¤í•˜ê²Œ ë°°ì¹˜)
                'zigzag',        // ì§€ê·¸ì¬ê·¸ í˜•íƒœ
                'platform'       // í”Œë«í¼ í˜•íƒœ (ì¤‘ê°„ì— í° ê³µê°„)
            ];

            const patternType = floatingPatterns[(level + obstacleIndex) % floatingPatterns.length];

            switch(patternType) {
                case 'bridge':
                    generateBridgePattern(targetRow);
                    break;
                case 'islands':
                    generateIslandsPattern(targetRow);
                    break;
                case 'tunnel':
                    generateTunnelPattern(targetRow);
                    break;
                case 'scattered':
                    generateScatteredPattern(targetRow);
                    break;
                case 'zigzag':
                    generateZigzagPattern(targetRow, obstacleIndex);
                    break;
                case 'platform':
                    generatePlatformPattern(targetRow);
                    break;
            }
        }

        function generateBridgePattern(targetRow) {
            // ì–‘ìª½ ë 1-2ì¹¸ë§Œ ë¹„ì›Œë‘ê³  ë‚˜ë¨¸ì§€ ì±„ì›€
            const leftGap = 1 + Math.floor(Math.random() * 2);
            const rightGap = 1 + Math.floor(Math.random() * 2);

            for (let col = leftGap; col < COLS - rightGap; col++) {
                board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
            }
        }

        function generateIslandsPattern(targetRow) {
            // ì‘ì€ ë¸”ë¡ ë©ì–´ë¦¬ë“¤ ìƒì„±
            const islands = Math.floor(Math.random() * 3) + 2; // 2-4ê°œì˜ ì„¬

            for (let i = 0; i < islands; i++) {
                const islandSize = Math.floor(Math.random() * 3) + 1; // 1-3ì¹¸ í¬ê¸°
                const startCol = Math.floor(Math.random() * (COLS - islandSize));

                for (let j = 0; j < islandSize; j++) {
                    if (startCol + j < COLS && board[targetRow][startCol + j] === 0) {
                        board[targetRow][startCol + j] = Math.floor(Math.random() * 7) + 1;
                    }
                }
            }
        }

        function generateTunnelPattern(targetRow) {
            // ê°€ìš´ë° 2-4ì¹¸ë§Œ ë¹„ì›Œë‘ê³  ë‚˜ë¨¸ì§€ ì±„ì›€
            const tunnelSize = 2 + Math.floor(Math.random() * 3);
            const tunnelStart = Math.floor((COLS - tunnelSize) / 2);

            for (let col = 0; col < COLS; col++) {
                if (col < tunnelStart || col >= tunnelStart + tunnelSize) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateScatteredPattern(targetRow) {
            // ëœë¤í•˜ê²Œ 50-70% ì •ë„ ì±„ì›€
            const fillRate = 0.5 + Math.random() * 0.2;

            for (let col = 0; col < COLS; col++) {
                if (Math.random() < fillRate) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generateZigzagPattern(targetRow, index) {
            // ì§€ê·¸ì¬ê·¸ í˜•íƒœë¡œ ë°°ì¹˜
            const direction = index % 2 === 0 ? 1 : -1;

            for (let col = 0; col < COLS; col++) {
                const height = Math.sin((col * Math.PI * 2) / COLS) * direction;
                if (height > 0) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function generatePlatformPattern(targetRow) {
            // ì¤‘ê°„ì— í° ê³µê°„ì„ ë‘” í”Œë«í¼
            const platformSize = 3 + Math.floor(Math.random() * 3); // 3-5ì¹¸ ê³µê°„
            const platformStart = Math.floor((COLS - platformSize) / 2);

            // ì–‘ìª½ì—ë§Œ ë¸”ë¡ ë°°ì¹˜
            for (let col = 0; col < platformStart; col++) {
                if (Math.random() < 0.8) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }

            for (let col = platformStart + platformSize; col < COLS; col++) {
                if (Math.random() < 0.8) {
                    board[targetRow][col] = Math.floor(Math.random() * 7) + 1;
                }
            }
        }

        function showLevelTransition(newLevel) {
            const transitionElement = document.getElementById('levelTransition');
            const levelNumberElement = document.getElementById('nextLevelNumber');

            levelNumberElement.textContent = `Level ${newLevel}`;
            transitionElement.classList.add('show');

            // Pause game during transition
            isPaused = true;

            // Clear all blocks from the board when advancing to next level
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));

            // Generate obstacles for the new level
            generateObstacles(newLevel);

            setTimeout(() => {
                transitionElement.classList.remove('show');
                isPaused = false;
                lastTime = performance.now();
                update();
            }, 2000);
        }

        function clearLines() {
            let linesToClear = [];

            // í„°ëœ¨ë¦´ ë¼ì¸ë“¤ ì°¾ê¸°
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }

            if (linesToClear.length > 0) {
                // í„°ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
                playExplosionAnimation(linesToClear, () => {
                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì‹¤ì œ ë¼ì¸ ì œê±°
                    const linesCleared = linesToClear.length;

                    // ë¼ì¸ ì œê±°
                    linesToClear.sort((a, b) => a - b); // ìœ„ì—ì„œë¶€í„° ì œê±°
                    linesToClear.forEach(lineIndex => {
                        board.splice(lineIndex, 1);
                        board.unshift(Array(COLS).fill(0));
                    });

                    lines += linesCleared;
                    const oldLevel = level;
                    score += [0, 50, 150, 250, 400][linesCleared] * level;

                    // Show line clear effect
                    if (linesCleared >= 2) {
                        showLineClearEffect(linesCleared);

                        // Play special sounds for multi-line clears
                        switch(linesCleared) {
                            case 2:
                                playSound('good');
                                break;
                            case 3:
                                playSound('excellent');
                                break;
                            case 4:
                                playSound('great');
                                break;
                        }
                    } else {
                        playSound('clear');
                    }

                    // Calculate new level based on score
                    level = calculateLevel(score);
                    nextLevelScore = getNextLevelScore(level);
                    dropInterval = calculateDropSpeed(level);

                    // Show level transition if level increased
                    if (level > oldLevel) {
                        showLevelTransition(level);
                        playSound('levelUp');
                    }

                    updateScore();
                });
            }
        }

        function playExplosionAnimation(linesToClear, callback) {
            const explosionDuration = 700; // 0.7ì´ˆë¡œ ì¦ê°€ (ê¹œë¹¡ì„ ì¶”ê°€)
            const startTime = performance.now();
            let animationPhase = 0; // 0: íŒ½ì°½, 1: ê¹œë¹¡ì„, 2: í­ë°œ, 3: ì™„ë£Œ

            function animateExplosion(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = elapsed / explosionDuration;

                if (progress < 0.15) {
                    // 1ë‹¨ê³„: ë¸”ë¡ë“¤ì´ ì‚´ì§ íŒ½ì°½ (0~0.15ì´ˆ)
                    animationPhase = 0;
                    const scaleProgress = progress / 0.15;
                    const scale = 1 + scaleProgress * 0.3; // 1.0 â†’ 1.3ë°°
                    drawBoard();
                    drawExpandingBlocks(linesToClear, scale);
                } else if (progress < 0.35) {
                    // 2ë‹¨ê³„: ê²©ë ¬í•œ ê¹œë¹¡ì„ (0.15~0.35ì´ˆ)
                    animationPhase = 1;
                    const flashElapsed = elapsed - (explosionDuration * 0.15);
                    const flashIntensity = Math.sin(flashElapsed * 25) > 0 ? 1 : 0.2; // ë¹ ë¥¸ ê¹œë¹¡ì„
                    drawBoard();
                    drawExpandingBlocks(linesToClear, 1.3); // ìµœëŒ€ í¬ê¸° ìœ ì§€
                    drawIntenseFlash(linesToClear, flashIntensity);
                } else if (progress < 0.55) {
                    // 3ë‹¨ê³„: ìˆœê°„ì  ëŒ€í­ë°œ (0.35~0.55ì´ˆ)
                    if (animationPhase === 1) {
                        animationPhase = 2;
                        createBalloonPopParticles(linesToClear);
                    }
                    const flashProgress = (progress - 0.35) / 0.2;
                    drawBoard();
                    drawMegaExplosionFlash(linesToClear, 1 - flashProgress);
                    drawBalloonPopParticles(flashProgress);
                } else {
                    // 4ë‹¨ê³„: íŒŒí‹°í´ ë§ˆë¬´ë¦¬ ë° ì¢…ë£Œ (0.55ì´ˆ ì´í›„)
                    if (progress < 1.0) {
                        const particleProgress = (progress - 0.55) / 0.45;
                        drawBoard();
                        drawBalloonPopParticles(particleProgress);
                    } else {
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ
                        drawBoard();
                        drawPiece();
                        callback();
                        return;
                    }
                }

                drawPiece();
                requestAnimationFrame(animateExplosion);
            }

            requestAnimationFrame(animateExplosion);
        }

        let balloonPopParticles = [];

        function drawExpandingBlocks(linesToClear, scale) {
            // í„°ì§ˆ ë¸”ë¡ë“¤ì„ í™•ëŒ€í•´ì„œ ê·¸ë¦¬ê¸° (í’ì„  ë¶€í’€ë¦¬ëŠ” íš¨ê³¼)
            ctx.save();
            linesToClear.forEach(row => {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] !== 0) {
                        const centerX = col * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const centerY = row * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const scaledSize = BLOCK_SIZE * scale;

                        // í™•ëŒ€ëœ ë¸”ë¡ ê·¸ë¦¬ê¸°
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.scale(scale, scale);
                        ctx.translate(-BLOCK_SIZE / 2, -BLOCK_SIZE / 2);

                        // ì›ë˜ ë¸”ë¡ë³´ë‹¤ ë°ê²Œ
                        const color = COLORS[board[row][col]];
                        ctx.fillStyle = color;
                        ctx.fillRect(0, 0, BLOCK_SIZE, BLOCK_SIZE);

                        // í•˜ì´ë¼ì´íŠ¸ íš¨ê³¼
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(0, 0, BLOCK_SIZE, BLOCK_SIZE);

                        ctx.restore();
                    }
                }
            });
            ctx.restore();
        }

        function createBalloonPopParticles(linesToClear) {
            balloonPopParticles = [];

            linesToClear.forEach(row => {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] !== 0) {
                        const centerX = col * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const centerY = row * BLOCK_SIZE + BLOCK_SIZE / 2;

                        // ê° ë¸”ë¡ë§ˆë‹¤ 8ë°©í–¥ìœ¼ë¡œ íŒŒí‹°í´ ìƒì„± (íŒ¡! í„°ì§€ëŠ” íš¨ê³¼)
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const speed = 4 + Math.random() * 6;

                            balloonPopParticles.push({
                                x: centerX,
                                y: centerY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                color: COLORS[board[row][col]],
                                size: 3 + Math.random() * 4,
                                life: 1.0,
                                maxLife: 1.0
                            });
                        }

                        // ì¶”ê°€ë¡œ ì‘ì€ ì”í•´ íŒŒí‹°í´ë“¤
                        for (let i = 0; i < 5; i++) {
                            balloonPopParticles.push({
                                x: centerX + (Math.random() - 0.5) * BLOCK_SIZE,
                                y: centerY + (Math.random() - 0.5) * BLOCK_SIZE,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8,
                                color: COLORS[board[row][col]],
                                size: 1 + Math.random() * 3,
                                life: 1.0,
                                maxLife: 1.0
                            });
                        }
                    }
                }
            });
        }

        function drawIntenseFlash(linesToClear, intensity) {
            // ê²©ë ¬í•œ ê¹œë¹¡ì„ (íŒ½ì°½ í›„ í­ë°œ ì§ì „)
            ctx.fillStyle = `rgba(255, 255, 0, ${intensity * 0.7})`; // ë…¸ë€ìƒ‰ ê¹œë¹¡ì„
            linesToClear.forEach(row => {
                ctx.fillRect(0, row * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
            });

            // ì¶”ê°€ í™”ì´íŠ¸ ì˜¤ë²„ë ˆì´
            ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.5})`;
            linesToClear.forEach(row => {
                ctx.fillRect(0, row * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
            });
        }

        function drawMegaExplosionFlash(linesToClear, intensity) {
            // ëŒ€í­ë°œ ìˆœê°„ - í™”ë©´ ì „ì²´ê°€ ë°ì•„ì§
            if (intensity > 0.5) {
                // ì „ì²´ í™”ë©´ í”Œë˜ì‹œ
                ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.8})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // í„°ì§„ ë¼ì¸ íŠ¹ë³„ íš¨ê³¼
            ctx.fillStyle = `rgba(255, 200, 0, ${intensity})`;
            linesToClear.forEach(row => {
                // ë¼ì¸ í™•ì¥ íš¨ê³¼
                const expand = intensity * 10;
                ctx.fillRect(-expand, row * BLOCK_SIZE - expand,
                           canvas.width + expand * 2, BLOCK_SIZE + expand * 2);
            });
        }

        function drawBalloonPopParticles(progress) {
            ctx.save();

            balloonPopParticles.forEach(particle => {
                if (particle.life > 0) {
                    // íŒŒí‹°í´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    particle.x += particle.vx;
                    particle.y += particle.vy;

                    // ë§ˆì°°ë¡œ ì†ë„ ê°ì†Œ
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;

                    // ìƒëª…ë ¥ ê°ì†Œ
                    particle.life -= 0.025;

                    // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;

                    // í¬ê¸°ê°€ ì ì  ì‘ì•„ì§
                    const currentSize = particle.size * (particle.life / particle.maxLife);
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();

                    // í°ìƒ‰ í•˜ì´ë¼ì´íŠ¸
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, currentSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();

            // ì£½ì€ íŒŒí‹°í´ ì œê±°
            balloonPopParticles = balloonPopParticles.filter(p => p.life > 0);
        }

        function drop() {
            if (collision(currentPiece, currentX, currentY + 1)) {
                merge();
                playSound('drop');
                clearLines();
                spawnPiece();
            } else {
                currentY++;
            }
        }

        function hardDrop() {
            while (!collision(currentPiece, currentX, currentY + 1)) {
                currentY++;
            }
            merge();
            playSound('drop');
            clearLines();
            spawnPiece();
        }

        function moveLeft() {
            if (!collision(currentPiece, currentX - 1, currentY)) {
                currentX--;
                playSound('move');
            }
        }

        function moveRight() {
            if (!collision(currentPiece, currentX + 1, currentY)) {
                currentX++;
                playSound('move');
            }
        }

        function rotatePiece() {
            const rotated = rotate(currentPiece);
            if (!collision(rotated, currentX, currentY)) {
                currentPiece = rotated;
                playSound('rotate');
            } else if (!collision(rotated, currentX + 1, currentY)) {
                currentX++;
                currentPiece = rotated;
                playSound('rotate');
            } else if (!collision(rotated, currentX - 1, currentY)) {
                currentX--;
                currentPiece = rotated;
                playSound('rotate');
            }
        }

        function spawnPiece() {
            currentPiece = nextPiece || createPiece();
            nextPiece = createPiece();
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
            currentY = -1;
            
            if (collision(currentPiece, currentX, currentY)) {
                gameOver();
            }
            
            drawNextPiece();
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;

            // Update next level requirement
            if (level >= LEVEL_THRESHOLDS.length) {
                document.getElementById('nextLevel').textContent = "ìµœê³  ë ˆë²¨!";
            } else {
                const remaining = nextLevelScore - score;
                document.getElementById('nextLevel').textContent = `ë‹¤ìŒ: ${remaining}ì  ë‚¨ìŒ`;
            }
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(gameLoop);
            stopBackgroundMusic();
            playSound('gameOver');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').classList.add('show');
        }

        function togglePause() {
            if (isGameOver) return;
            
            isPaused = !isPaused;
            document.getElementById('pauseIndicator').classList.toggle('show', isPaused);
            
            if (!isPaused) {
                lastTime = performance.now();
                update();
            }
        }

        function restartGame() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
            score = 0;
            level = 1;
            lines = 0;
            nextLevelScore = 500;
            dropInterval = 1000;
            isPaused = false;
            isGameOver = false;
            gameStartTime = performance.now(); // ê²Œì„ ì‹œì‘ ì‹œê°„ ì´ˆê¸°í™”
            timeSpeedBonus = 0;                // ì‹œê°„ ë³´ë„ˆìŠ¤ ì´ˆê¸°í™”

            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('pauseIndicator').classList.remove('show');

            // ê²Œì„ ì‹œì‘ ì‹œì—ëŠ” ì¥ì• ë¬¼ ì—†ìŒ (ë ˆë²¨ 1ì´ë¯€ë¡œ)
            updateScore();
            nextPiece = createPiece();
            spawnPiece();
            lastTime = performance.now();
            update();
        }

        function update(time = 0) {
            if (isPaused || isGameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            // ì‹œê°„ì— ë”°ë¥¸ ì†ë„ ì—…ë°ì´íŠ¸ (5ì´ˆë§ˆë‹¤ í•œ ë²ˆì”©)
            if (Math.floor(time / 5000) > Math.floor((time - deltaTime) / 5000)) {
                dropInterval = calculateDropSpeed(level);
            }

            if (dropCounter > dropInterval) {
                drop();
                dropCounter = 0;
            }

            drawBoard();
            drawPiece();

            gameLoop = requestAnimationFrame(update);
        }

        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;

            // í…ŒíŠ¸ë¦¬ìŠ¤ ì¡°ì‘í‚¤ë§Œ ì²˜ë¦¬í•˜ê³  ë‹¤ë¥¸ í‚¤ëŠ” ê¸°ë³¸ ë™ì‘ í—ˆìš©
            const tetrisKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'p', 'P'];

            if (!tetrisKeys.includes(e.key)) return;

            // í…ŒíŠ¸ë¦¬ìŠ¤ í‚¤ëŠ” ê¸°ë³¸ ë™ì‘ ë°©ì§€
            e.preventDefault();

            if (e.key === 'p' || e.key === 'P') {
                togglePause();
                return;
            }

            if (isPaused) return;

            switch(e.key) {
                case 'ArrowLeft':
                    moveLeft();
                    break;
                case 'ArrowRight':
                    moveRight();
                    break;
                case 'ArrowDown':
                    drop();
                    dropCounter = 0;
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ':
                    hardDrop();
                    dropCounter = 0;
                    break;
            }

            drawBoard();
            drawPiece();
        });

        updateScore();
        gameStartTime = performance.now(); // ì´ˆê¸° ê²Œì„ ì‹œì‘ ì‹œê°„ ì„¤ì •
        nextPiece = createPiece();
        spawnPiece();
        lastTime = performance.now();
        update();
    </script>
</body>
</html>